// Thanks to http://www.htmlescape.net/stringescape_tool.html
var sourceCodesHacking = {
    "vigenereHacker": "# Vigenere Cipher Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport itertools, re\nimport vigenereCipher, pyperclip, freqAnalysis, detectEnglish\n\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\nSILENT_MODE = False # if set to True, program doesn\'t print attempts\nNUM_MOST_FREQ_LETTERS = 4 # attempts this many letters per subkey\nMAX_KEY_LENGTH = 16 # will not attempt keys longer than this\nNONLETTERS_PATTERN = re.compile(\'[^A-Z]\')\n\n\ndef main():\n    # Instead of typing this ciphertext out, you can copy \& paste it\n    # from http:\x2F\x2Finvpy.com\x2FvigenereHacker.py\n    ciphertext = \"\"\"Adiz Avtzqeci Tmzubb wsa m Pmilqev halpqavtakuoi, lgouqdaf, kdmktsvmztsl, izr xoexghzr kkusitaaf. Vz wsa twbhdg ubalmmzhdad qz hce vmhsgohuqbo ox kaakulmd gxiwvos, krgdurdny i rcmmstugvtawz ca tzm ocicwxfg jf \"stscmilpy\" oid \"uwydptsbuci\" wabt hce Lcdwig eiovdnw. Bgfdny qe kddwtk qjnkqpsmev ba pz tzm roohwz at xoexghzr kkusicw izr vrlqrwxist uboedtuuznum. Pimifo Icmlv Emf DI, Lcdwig owdyzd xwd hce Ywhsmnemzh Xovm mby Cqxtsm Supacg (GUKE) oo Bdmfqclwg Bomk, Tzuhvif\'a ocyetzqofifo ositjm. Rcm a lqys ce oie vzav wr Vpt 8, lpq gzclqab mekxabnittq tjr Ymdavn fihog cjgbhvnstkgds. Zm psqikmp o iuejqf jf lmoviiicqg aoj jdsvkavs Uzreiz qdpzmdg, dnutgrdny bts helpar jf lpq pjmtm, mb zlwkffjmwktoiiuix avczqzs ohsb ocplv nuby swbfwigk naf ohw Mzwbms umqcifm. Mtoej bts raj pq kjrcmp oo tzm Zooigvmz Khqauqvl Dincmalwdm, rhwzq vz cjmmhzd gvq ca tzm rwmsl lqgdgfa rcm a kbafzd-hzaumae kaakulmd, hce SKQ. Wi 1948 Tmzubb jgqzsy Msf Zsrmsv\'e Qjmhcfwig Dincmalwdm vt Eizqcekbqf Pnadqfnilg, ivzrw pq onsaafsy if bts yenmxckmwvf ca tzm Yoiczmehzr uwydptwze oid tmoohe avfsmekbqr dn eifvzmsbuqvl tqazjgq. Pq kmolm m dvpwz ab ohw ktshiuix pvsaa at hojxtcbefmewn, afl bfzdakfsy okkuzgalqzu xhwuuqvl jmmqoigve gpcz ie hce Tmxcpsgd-Lvvbgbubnkq zqoxtawz, kciup isme xqdgo otaqfqev qz hce 1960k. Bgfdny\'a tchokmjivlabk fzsmtfsy if i ofdmavmz krgaqqptawz wi 1952, wzmz vjmgaqlpad iohn wwzq goidt uzgeyix wi tzm Gbdtwl Wwigvwy. Vz aukqdoev bdsvtemzh rilp rshadm tcmmgvqg (xhwuuqvl uiehmalqab) vs sv mzoejvmhdvw ba dmikwz. Hpravs rdev qz 1954, xpsl whsm tow iszkk jqtjrw pug 42id tqdhcdsg, rfjm ugmbddw xawnofqzu. Vn avcizsl lqhzreqzsy tzif vds vmmhc wsa eidcalq; vds ewfvzr svp gjmw wfvzrk jqzdenmp vds vmmhc wsa mqxivmzhvl. Gv 10 Esktwunsm 2009, fgtxcrifo mb Dnlmdbzt uiydviyv, Nfdtaat Dmiem Ywiikbqf Bojlab Wrgez avdw iz cafakuog pmjxwx ahwxcby gv nscadn at ohw Jdwoikp scqejvysit xwd \"hce sxboglavs kvy zm ion tjmmhzd.\" Sa at Haq 2012 i bfdvsbq azmtmd\'g widt ion bwnafz tzm Tcpsw wr Zjrva ivdcz eaigd yzmbo Tmzubb a kbmhptgzk dvrvwz wa efiohzd.\"\"\"\n    hackedMessage = hackVigenere(ciphertext)\n\n    if hackedMessage != None:\n        print(\'Copying hacked message to clipboard:\')\n        print(hackedMessage)\n        pyperclip.copy(hackedMessage)\n    else:\n        print(\'Failed to hack encryption.\')\n\n\ndef findRepeatSequencesSpacings(message):\n    # Goes through the message and finds any 3 to 5 letter sequences\n    # that are repeated. Returns a dict with the keys of the sequence and\n    # values of a list of spacings (num of letters between the repeats).\n\n    # Use a regular expression to remove non-letters from the message.\n    message = NONLETTERS_PATTERN.sub(\'\', message.upper())\n\n    # Compile a list of seqLen-letter sequences found in the message.\n    seqSpacings = {} # keys are sequences, values are list of int spacings\n    for seqLen in range(3, 6):\n        for seqStart in range(len(message) - seqLen):\n            # Determine what the sequence is, and store it in seq\n            seq = message[seqStart:seqStart + seqLen]\n\n            # Look for this sequence in the rest of the message\n            for i in range(seqStart + seqLen, len(message) - seqLen):\n                if message[i:i + seqLen] == seq:\n                    # Found a repeated sequence.\n                    if seq not in seqSpacings:\n                        seqSpacings[seq] = [] # initialize blank list\n\n                    # Append the spacing distance between the repeated\n                    # sequence and the original sequence.\n                    seqSpacings[seq].append(i - seqStart)\n    return seqSpacings\n\n\ndef getUsefulFactors(num):\n    # Returns a list of useful factors of num. By \"useful\" we mean factors\n    # less than MAX_KEY_LENGTH + 1. For example, getUsefulFactors(144)\n    # returns [2, 72, 3, 48, 4, 36, 6, 24, 8, 18, 9, 16, 12]\n\n    if num \x3C 2:\n        return [] # numbers less than 2 have no useful factors\n\n    factors = [] # the list of factors found\n\n    # When finding factors, you only need to check the integers up to\n    # MAX_KEY_LENGTH.\n    for i in range(2, MAX_KEY_LENGTH + 1): # don\'t test 1\n        if num % i == 0:\n            factors.append(i)\n            factors.append(int(num \x2F i))\n    if 1 in factors:\n        factors.remove(1)\n    return list(set(factors))\n\n\ndef getItemAtIndexOne(x):\n    return x[1]\n\n\ndef getMostCommonFactors(seqFactors):\n    # First, get a count of how many times a factor occurs in seqFactors.\n    factorCounts = {} # key is a factor, value is how often if occurs\n\n    # seqFactors keys are sequences, values are lists of factors of the\n    # spacings. seqFactors has a value like: {\'GFD\': [2, 3, 4, 6, 9, 12,\n    # 18, 23, 36, 46, 69, 92, 138, 207], \'ALW\': [2, 3, 4, 6, ...], ...}\n    for seq in seqFactors:\n        factorList = seqFactors[seq]\n        for factor in factorList:\n            if factor not in factorCounts:\n                factorCounts[factor] = 0\n            factorCounts[factor] += 1\n\n    # Second, put the factor and its count into a tuple, and make a list\n    # of these tuples so we can sort them.\n    factorsByCount = []\n    for factor in factorCounts:\n        # exclude factors larger than MAX_KEY_LENGTH\n        if factor \x3C= MAX_KEY_LENGTH:\n            # factorsByCount is a list of tuples: (factor, factorCount)\n            # factorsByCount has a value like: [(3, 497), (2, 487), ...]\n            factorsByCount.append( (factor, factorCounts[factor]) )\n\n    # Sort the list by the factor count.\n    factorsByCount.sort(key=getItemAtIndexOne, reverse=True)\n\n    return factorsByCount\n\n\ndef kasiskiExamination(ciphertext):\n    # Find out the sequences of 3 to 5 letters that occur multiple times\n    # in the ciphertext. repeatedSeqSpacings has a value like:\n    # {\'EXG\': [192], \'NAF\': [339, 972, 633], ... }\n    repeatedSeqSpacings = findRepeatSequencesSpacings(ciphertext)\n\n    # See getMostCommonFactors() for a description of seqFactors.\n    seqFactors = {}\n    for seq in repeatedSeqSpacings:\n        seqFactors[seq] = []\n        for spacing in repeatedSeqSpacings[seq]:\n            seqFactors[seq].extend(getUsefulFactors(spacing))\n\n    # See getMostCommonFactors() for a description of factorsByCount.\n    factorsByCount = getMostCommonFactors(seqFactors)\n\n    # Now we extract the factor counts from factorsByCount and\n    # put them in allLikelyKeyLengths so that they are easier to\n    # use later.\n    allLikelyKeyLengths = []\n    for twoIntTuple in factorsByCount:\n        allLikelyKeyLengths.append(twoIntTuple[0])\n\n    return allLikelyKeyLengths\n\n\ndef getNthSubkeysLetters(n, keyLength, message):\n    # Returns every Nth letter for each keyLength set of letters in text.\n    # E.g. getNthSubkeysLetters(1, 3, \'ABCABCABC\') returns \'AAA\'\n    #      getNthSubkeysLetters(2, 3, \'ABCABCABC\') returns \'BBB\'\n    #      getNthSubkeysLetters(3, 3, \'ABCABCABC\') returns \'CCC\'\n    #      getNthSubkeysLetters(1, 5, \'ABCDEFGHI\') returns \'AF\'\n\n    # Use a regular expression to remove non-letters from the message.\n    message = NONLETTERS_PATTERN.sub(\'\', message)\n\n    i = n - 1\n    letters = []\n    while i \x3C len(message):\n        letters.append(message[i])\n        i += keyLength\n    return \'\'.join(letters)\n\n\ndef attemptHackWithKeyLength(ciphertext, mostLikelyKeyLength):\n    # Determine the most likely letters for each letter in the key.\n    ciphertextUp = ciphertext.upper()\n    # allFreqScores is a list of mostLikelyKeyLength number of lists.\n    # These inner lists are the freqScores lists.\n    allFreqScores = []\n    for nth in range(1, mostLikelyKeyLength + 1):\n        nthLetters = getNthSubkeysLetters(nth, mostLikelyKeyLength, ciphertextUp)\n\n        # freqScores is a list of tuples like:\n        # [(\x3Cletter\x3E, \x3CEng. Freq. match score\x3E), ... ]\n        # List is sorted by match score. Higher score means better match.\n        # See the englishFreqMatchScore() comments in freqAnalysis.py.\n        freqScores = []\n        for possibleKey in LETTERS:\n            decryptedText = vigenereCipher.decryptMessage(possibleKey, nthLetters)\n            keyAndFreqMatchTuple = (possibleKey, freqAnalysis.englishFreqMatchScore(decryptedText))\n            freqScores.append(keyAndFreqMatchTuple)\n        # Sort by match score\n        freqScores.sort(key=getItemAtIndexOne, reverse=True)\n\n        allFreqScores.append(freqScores[:NUM_MOST_FREQ_LETTERS])\n\n    if not SILENT_MODE:\n        for i in range(len(allFreqScores)):\n            # use i + 1 so the first letter is not called the \"0th\" letter\n            print(\'Possible letters for letter %s of the key: \' % (i + 1), end=\'\')\n            for freqScore in allFreqScores[i]:\n                print(\'%s \' % freqScore[0], end=\'\')\n            print() # print a newline\n\n    # Try every combination of the most likely letters for each position\n    # in the key.\n    for indexes in itertools.product(range(NUM_MOST_FREQ_LETTERS), repeat=mostLikelyKeyLength):\n        # Create a possible key from the letters in allFreqScores\n        possibleKey = \'\'\n        for i in range(mostLikelyKeyLength):\n            possibleKey += allFreqScores[i][indexes[i]][0]\n\n        if not SILENT_MODE:\n            print(\'Attempting with key: %s\' % (possibleKey))\n\n        decryptedText = vigenereCipher.decryptMessage(possibleKey, ciphertextUp)\n\n        if detectEnglish.isEnglish(decryptedText):\n            # Set the hacked ciphertext to the original casing.\n            origCase = []\n            for i in range(len(ciphertext)):\n                if ciphertext[i].isupper():\n                    origCase.append(decryptedText[i].upper())\n                else:\n                    origCase.append(decryptedText[i].lower())\n            decryptedText = \'\'.join(origCase)\n\n            # Check with user to see if the key has been found.\n            print(\'Possible encryption hack with key %s:\' % (possibleKey))\n            print(decryptedText[:200]) # only show first 200 characters\n            print()\n            print(\'Enter D for done, or just press Enter to continue hacking:\')\n            response = input(\'\x3E \')\n\n            if response.strip().upper().startswith(\'D\'):\n                return decryptedText\n\n    # No English-looking decryption found, so return None.\n    return None\n\n\ndef hackVigenere(ciphertext):\n    # First, we need to do Kasiski Examination to figure out what the\n    # length of the ciphertext\'s encryption key is.\n    allLikelyKeyLengths = kasiskiExamination(ciphertext)\n    if not SILENT_MODE:\n        keyLengthStr = \'\'\n        for keyLength in allLikelyKeyLengths:\n            keyLengthStr += \'%s \' % (keyLength)\n        print(\'Kasiski Examination results say the most likely key lengths are: \' + keyLengthStr + \'\\n\')\n\n    for keyLength in allLikelyKeyLengths:\n        if not SILENT_MODE:\n            print(\'Attempting hack with key length %s (%s possible keys)...\' % (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength))\n        hackedMessage = attemptHackWithKeyLength(ciphertext, keyLength)\n        if hackedMessage != None:\n            break\n\n    # If none of the key lengths we found using Kasiski Examination\n    # worked, start brute-forcing through key lengths.\n    if hackedMessage == None:\n        if not SILENT_MODE:\n            print(\'Unable to hack message with likely key length(s). Brute forcing key length...\')\n        for keyLength in range(1, MAX_KEY_LENGTH + 1):\n            # don\'t re-check key lengths already tried from Kasiski\n            if keyLength not in allLikelyKeyLengths:\n                if not SILENT_MODE:\n                    print(\'Attempting hack with key length %s (%s possible keys)...\' % (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength))\n                hackedMessage = attemptHackWithKeyLength(ciphertext, keyLength)\n                if hackedMessage != None:\n                    break\n    return hackedMessage\n\n\n# If vigenereHacker.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "vigenereDictionaryHacker": "# Vigenere Cipher Dictionary Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport detectEnglish, vigenereCipher, pyperclip\n\ndef main():\n    ciphertext = \"\"\"Tzx isnz eccjxkg nfq lol mys bbqq I lxcz.\"\"\"\n    hackedMessage = hackVigenere(ciphertext)\n\n    if hackedMessage != None:\n        print(\'Copying hacked message to clipboard:\')\n        print(hackedMessage)\n        pyperclip.copy(hackedMessage)\n    else:\n        print(\'Failed to hack encryption.\')\n\n\ndef hackVigenere(ciphertext):\n    fo = open(\'dictionary.txt\')\n    words = fo.readlines()\n    fo.close()\n\n    for word in words:\n        word = word.strip() # remove the newline at the end\n        decryptedText = vigenereCipher.decryptMessage(word, ciphertext)\n        if detectEnglish.isEnglish(decryptedText, wordPercentage=40):\n            # Check with user to see if the decrypted key has been found.\n            print()\n            print(\'Possible encryption break:\')\n            print(\'Key \' + str(word) + \': \' + decryptedText[:100])\n            print()\n            print(\'Enter D for done, or just press Enter to continue breaking:\')\n            response = input(\'\x3E \')\n\n            if response.upper().startswith(\'D\'):\n                return decryptedText\n\nif __name__ == \'__main__\':\n    main()\n",
    "vigenereCipher": "# Vigenere Cipher (Polyalphabetic Substitution Cipher)\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip\n\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\ndef main():\n    # This text can be copy\x2Fpasted from http:\x2F\x2Finvpy.com\x2FvigenereCipher.py\n    myMessage = \"\"\"Alan Mathison Turing was a British mathematician, logician, cryptanalyst, and computer scientist. He was highly influential in the development of computer science, providing a formalisation of the concepts of \"algorithm\" and \"computation\" with the Turing machine. Turing is widely considered to be the father of computer science and artificial intelligence. During World War II, Turing worked for the Government Code and Cypher School (GCCS) at Bletchley Park, Britain\'s codebreaking centre. For a time he was head of Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for breaking German ciphers, including the method of the bombe, an electromechanical machine that could find settings for the Enigma machine. After the war he worked at the National Physical Laboratory, where he created one of the first designs for a stored-program computer, the ACE. In 1948 Turing joined Max Newman\'s Computing Laboratory at Manchester University, where he assisted in the development of the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov-Zhabotinsky reaction, which were first observed in the 1960s. Turing\'s homosexuality resulted in a criminal prosecution in 1952, when homosexual acts were still illegal in the United Kingdom. He accepted treatment with female hormones (chemical castration) as an alternative to prison. Turing died in 1954, just over two weeks before his 42nd birthday, from cyanide poisoning. An inquest determined that his death was suicide; his mother and some others believed his death was accidental. On 10 September 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" As of May 2012 a private member\'s bill was before the House of Lords which would grant Turing a statutory pardon if enacted.\"\"\"\n    myKey = \'ASIMOV\'\n    myMode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n    if myMode == \'encrypt\':\n        translated = encryptMessage(myKey, myMessage)\n    elif myMode == \'decrypt\':\n        translated = decryptMessage(myKey, myMessage)\n\n    print(\'%sed message:\' % (myMode.title()))\n    print(translated)\n    pyperclip.copy(translated)\n    print()\n    print(\'The message has been copied to the clipboard.\')\n\n\ndef encryptMessage(key, message):\n    return translateMessage(key, message, \'encrypt\')\n\n\ndef decryptMessage(key, message):\n    return translateMessage(key, message, \'decrypt\')\n\n\ndef translateMessage(key, message, mode):\n    translated = [] # stores the encrypted\x2Fdecrypted message string\n\n    keyIndex = 0\n    key = key.upper()\n\n    for symbol in message: # loop through each character in message\n        num = LETTERS.find(symbol.upper())\n        if num != -1: # -1 means symbol.upper() was not found in LETTERS\n            if mode == \'encrypt\':\n                num += LETTERS.find(key[keyIndex]) # add if encrypting\n            elif mode == \'decrypt\':\n                num -= LETTERS.find(key[keyIndex]) # subtract if decrypting\n\n            num %= len(LETTERS) # handle the potential wrap-around\n\n            # add the encrypted\x2Fdecrypted symbol to the end of translated.\n            if symbol.isupper():\n                translated.append(LETTERS[num])\n            elif symbol.islower():\n                translated.append(LETTERS[num].lower())\n\n            keyIndex += 1 # move to the next letter in the key\n            if keyIndex == len(key):\n                keyIndex = 0\n        else:\n            # The symbol was not in LETTERS, so add it to translated as is.\n            translated.append(symbol)\n\n    return \'\'.join(translated)\n\n\n# If vigenereCipher.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionTest": "# Transposition Cipher Test\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport random, sys, transpositionEncrypt, transpositionDecrypt\n\ndef main():\n    random.seed(42) # set the random \"seed\" to a static value\n\n    for i in range(20): # run 20 tests\n        # Generate random messages to test.\n\n        # The message will have a random length:\n        message = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\' * random.randint(4, 40)\n\n        # Convert the message string to a list to shuffle it.\n        message = list(message)\n        random.shuffle(message)\n        message = \'\'.join(message) # convert list to string\n\n        print(\'Test #%s: \"%s...\"\' % (i+1, message[:50]))\n\n        # Check all possible keys for each message.\n        for key in range(1, len(message)):\n            encrypted = transpositionEncrypt.encryptMessage(key, message)\n            decrypted = transpositionDecrypt.decryptMessage(key, encrypted)\n\n            # If the decryption doesn\'t match the original message, display\n            # an error message and quit.\n            if message != decrypted:\n                print(\'Mismatch with key %s and message %s.\' % (key, message))\n                print(decrypted)\n                sys.exit()\n\n    print(\'Transposition cipher test passed.\')\n\n\n# If transpositionTest.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionHacker": "# Transposition Cipher Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip, detectEnglish, transpositionDecrypt\n\ndef main():\n    # You might want to copy \& paste this text from the source code at\n    # http:\x2F\x2Finvpy.com\x2FtranspositionHacker.py\n    myMessage = \"\"\"Cb b rssti aieih rooaopbrtnsceee er es no npfgcwu  plri ch nitaalr eiuengiteehb(e1  hilincegeoamn fubehgtarndcstudmd nM eu eacBoltaeteeoinebcdkyremdteghn.aa2r81a condari fmps\" tad   l t oisn sit u1rnd stara nvhn fsedbh ee,n  e necrg6  8nmisv l nc muiftegiitm tutmg cm shSs9fcie ebintcaets h  aihda cctrhe ele 1O7 aaoem waoaatdahretnhechaopnooeapece9etfncdbgsoeb uuteitgna.rteoh add e,D7c1Etnpneehtn beete\" evecoal lsfmcrl iu1cifgo ai. sl1rchdnheev sh meBd ies e9t)nh,htcnoecplrrh ,ide hmtlme. pheaLem,toeinfgn t e9yce da\' eN eMp a ffn Fc1o ge eohg dere.eec s nfap yox hla yon. lnrnsreaBoa t,e eitsw il ulpbdofgBRe bwlmprraio po  droB wtinue r Pieno nc ayieeto\'lulcih sfnc  ownaSserbereiaSm-eaiah, nnrttgcC  maciiritvledastinideI  nn rms iehn tsigaBmuoetcetias rn\"\"\"\n\n    hackedMessage = hackTransposition(myMessage)\n\n    if hackedMessage == None:\n        print(\'Failed to hack encryption.\')\n    else:\n        print(\'Copying hacked message to clipboard:\')\n        print(hackedMessage)\n        pyperclip.copy(hackedMessage)\n\n\ndef hackTransposition(message):\n    print(\'Hacking...\')\n\n    # Python programs can be stopped at any time by pressing Ctrl-C (on\n    # Windows) or Ctrl-D (on Mac and Linux)\n    print(\'(Press Ctrl-C or Ctrl-D to quit at any time.)\')\n\n    # brute-force by looping through every possible key\n    for key in range(1, len(message)):\n        print(\'Trying key #%s...\' % (key))\n\n        decryptedText = transpositionDecrypt.decryptMessage(key, message)\n\n        if detectEnglish.isEnglish(decryptedText):\n            # Check with user to see if the decrypted key has been found.\n            print()\n            print(\'Possible encryption hack:\')\n            print(\'Key %s: %s\' % (key, decryptedText[:100]))\n            print()\n            print(\'Enter D for done, or just press Enter to continue hacking:\')\n            response = input(\'\x3E \')\n\n            if response.strip().upper().startswith(\'D\'):\n                return decryptedText\n\n    return None\n\nif __name__ == \'__main__\':\n    main()\n",
    "transpositionFileHacker": "# Transposition File Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport sys, time, os, sys, transpositionDecrypt, detectEnglish\n\ninputFilename = \'frankenstein.encrypted.txt\'\noutputFilename = \'frankenstein.decrypted.txt\'\n\ndef main():\n    if not os.path.exists(inputFilename):\n        print(\'The file %s does not exist. Quitting.\' % (inputFilename))\n        sys.exit()\n\n    inputFile = open(inputFilename)\n    content = inputFile.read()\n    inputFile.close()\n\n    brokenMessage = hackTransposition(content)\n\n    if brokenMessage != None:\n        print(\'Writing decrypted text to %s.\' % (outputFilename))\n\n        outputFile = open(outputFilename, \'w\')\n        outputFile.write(brokenMessage)\n        outputFile.close()\n    else:\n        print(\'Failed to hack encryption.\')\n\n\n# The hackTransposition() function\'s code was copy\x2Fpasted from\n# transpositionHacker.py and had some modifications made.\ndef hackTransposition(message):\n    print(\'Hacking...\')\n    # Python programs can be stopped at any time by pressing Ctrl-C (on\n    # Windows) or Ctrl-D (on Mac and Linux)\n    print(\'(Press Ctrl-C or Ctrl-D to quit at any time.)\')\n\n    for key in range(1, len(message)):\n        print(\'Trying key #%s... \' % (key), end=\'\')\n        sys.stdout.flush()\n\n        # We want to track the amount of time it takes to test a single key,\n        # so we record the time in startTime.\n        startTime = time.time()\n\n        decryptedText = transpositionDecrypt.decryptMessage(key, message)\n        englishPercentage = round(detectEnglish.getEnglishCount(decryptedText) * 100, 2)\n\n        totalTime = round(time.time() - startTime, 3)\n        print(\'Test time: %s seconds, \' % (totalTime), end=\'\')\n        sys.stdout.flush() # flush printed text to the screen\n\n        print(\'Percent English: %s%%\' % (englishPercentage))\n        if englishPercentage \x3E 20:\n            print()\n            print(\'Key \' + str(key) + \': \' + decryptedText[:100])\n            print()\n            print(\'Enter D for done, or just press Enter to continue:\')\n            response = input(\'\x3E \')\n            if response.strip().upper().startswith(\'D\'):\n                return decryptedText\n    return None\n\n\n# If transpositionFileHacker.py is run (instead of imported as a module)\n# call the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionFileCipher": "# Transposition Cipher Encrypt\x2FDecrypt File\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport time, os, sys, transpositionEncrypt, transpositionDecrypt\n\ndef main():\n    inputFilename = \'frankenstein.txt\'\n    # BE CAREFUL! If a file with the outputFilename name already exists,\n    # this program will overwrite that file.\n    outputFilename = \'frankenstein.encrypted.txt\'\n    myKey = 10\n    myMode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n    # If the input file does not exist, then the program terminates early.\n    if not os.path.exists(inputFilename):\n        print(\'The file %s does not exist. Quitting...\' % (inputFilename))\n        sys.exit()\n\n    # If the output file already exists, give the user a chance to quit.\n    if os.path.exists(outputFilename):\n        print(\'This will overwrite the file %s. (C)ontinue or (Q)uit?\' % (outputFilename))\n        response = input(\'\x3E \')\n        if not response.lower().startswith(\'c\'):\n            sys.exit()\n\n    # Read in the message from the input file\n    fileObj = open(inputFilename)\n    content = fileObj.read()\n    fileObj.close()\n\n    print(\'%sing...\' % (myMode.title()))\n\n    # Measure how long the encryption\x2Fdecryption takes.\n    startTime = time.time()\n    if myMode == \'encrypt\':\n        translated = transpositionEncrypt.encryptMessage(myKey, content)\n    elif myMode == \'decrypt\':\n        translated = transpositionDecrypt.decryptMessage(myKey, content)\n    totalTime = round(time.time() - startTime, 2)\n    print(\'%sion time: %s seconds\' % (myMode.title(), totalTime))\n\n    # Write out the translated message to the output file.\n    outputFileObj = open(outputFilename, \'w\')\n    outputFileObj.write(translated)\n    outputFileObj.close()\n\n    print(\'Done %sing %s (%s characters).\' % (myMode, inputFilename, len(content)))\n    print(\'%sed file is %s.\' % (myMode.title(), outputFilename))\n\n\n# If transpositionCipherFile.py is run (instead of imported as a module)\n# call the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionEncrypt": "# Transposition Cipher Encryption\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip\n\ndef main():\n    myMessage = \'Common sense is not so common.\'\n    myKey = 8\n\n    ciphertext = encryptMessage(myKey, myMessage)\n\n    # Print the encrypted string in ciphertext to the screen, with\n    # a | (called \"pipe\" character) after it in case there are spaces at\n    # the end of the encrypted message.\n    print(ciphertext + \'|\')\n\n    # Copy the encrypted string in ciphertext to the clipboard.\n    pyperclip.copy(ciphertext)\n\n\ndef encryptMessage(key, message):\n    # Each string in ciphertext represents a column in the grid.\n    ciphertext = [\'\'] * key\n\n    # Loop through each column in ciphertext.\n    for col in range(key):\n        pointer = col\n\n        # Keep looping until pointer goes past the length of the message.\n        while pointer \x3C len(message):\n            # Place the character at pointer in message at the end of the\n            # current column in the ciphertext list.\n            ciphertext[col] += message[pointer]\n\n            # move pointer over\n            pointer += key\n\n    # Convert the ciphertext list into a single string value and return it.\n    return \'\'.join(ciphertext)\n\n\n# If transpositionEncrypt.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionDecrypt": "# Transposition Cipher Decryption\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport math, pyperclip\n\ndef main():\n    myMessage = \'Cenoonommstmme oo snnio. s s c\'\n    myKey = 8\n\n    plaintext = decryptMessage(myKey, myMessage)\n\n    # Print with a | (called \"pipe\" character) after it in case\n    # there are spaces at the end of the decrypted message.\n    print(plaintext + \'|\')\n\n    pyperclip.copy(plaintext)\n\n\ndef decryptMessage(key, message):\n    # The transposition decrypt function will simulate the \"columns\" and\n    # \"rows\" of the grid that the plaintext is written on by using a list\n    # of strings. First, we need to calculate a few values.\n\n    # The number of \"columns\" in our transposition grid:\n    numOfColumns = math.ceil(len(message) \x2F key)\n    # The number of \"rows\" in our grid will need:\n    numOfRows = key\n    # The number of \"shaded boxes\" in the last \"column\" of the grid:\n    numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)\n\n    # Each string in plaintext represents a column in the grid.\n    plaintext = [\'\'] * numOfColumns\n\n    # The col and row variables point to where in the grid the next\n    # character in the encrypted message will go.\n    col = 0\n    row = 0\n\n    for symbol in message:\n        plaintext[col] += symbol\n        col += 1 # point to next column\n\n        # If there are no more columns OR we\'re at a shaded box, go back to\n        # the first column and the next row.\n        if (col == numOfColumns) or (col == numOfColumns - 1 and row \x3E= numOfRows - numOfShadedBoxes):\n            col = 0\n            row += 1\n\n    return \'\'.join(plaintext)\n\n\n# If transpositionDecrypt.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "simpleSubKeyword": "# Simple Substitution Keyword Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip, simpleSubCipher\n\ndef main():\n    myMessage = r\"\"\"Your cover is blown.\"\"\"\n    myKey = \'alphanumeric\'\n    myMode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n\n    print(\'The key used is:\')\n    print(makeSimpleSubKey(myKey))\n\n    if myMode == \'encrypt\':\n        translated = encryptMessage(myKey, myMessage)\n    elif myMode == \'decrypt\':\n        translated = decryptMessage(myKey, myMessage)\n\n    print(\'The %sed message is:\' % (myMode))\n    print(translated)\n\n    pyperclip.copy(translated)\n    print()\n    print(\'This message has been copied to the clipboard.\')\n\n\ndef encryptMessage(key, message):\n    key = makeSimpleSubKey(key)\n    return simpleSubCipher.encryptMessage(key, message)\n\n\ndef decryptMessage(key, message):\n    key = makeSimpleSubKey(key)\n    return simpleSubCipher.decryptMessage(key, message)\n\n\ndef makeSimpleSubKey(keyword):\n    # create the key from the keyword\n    newKey = \'\'\n    keyword = keyword.upper()\n    keyAlphabet = list(simpleSubCipher.LETTERS)\n    for i in range(len(keyword)):\n        if keyword[i] not in newKey:\n            newKey += keyword[i]\n            keyAlphabet.remove(keyword[i])\n    key = newKey + \'\'.join(keyAlphabet)\n    return key\n\n\nif __name__ == \'__main__\':\n    main()",
    "simpleSubHacker": "# Simple Substitution Cipher Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport os, re, copy, pprint, pyperclip, simpleSubCipher, makeWordPatterns\n\nif not os.path.exists(\'wordPatterns.py\'):\n    makeWordPatterns.main() # create the wordPatterns.py file\nimport wordPatterns\n\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\nnonLettersOrSpacePattern = re.compile(\'[^A-Z\\s]\')\n\ndef main():\n    message = \'Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor l calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh. -Facjclxo Ctrramm\'\n\n    # Determine the possible valid ciphertext translations.\n    print(\'Hacking...\')\n    letterMapping = hackSimpleSub(message)\n\n    # Display the results to the user.\n    print(\'Mapping:\')\n    pprint.pprint(letterMapping)\n    print()\n    print(\'Original ciphertext:\')\n    print(message)\n    print()\n    print(\'Copying hacked message to clipboard:\')\n    hackedMessage = decryptWithCipherletterMapping(message, letterMapping)\n    pyperclip.copy(hackedMessage)\n    print(hackedMessage)\n\n\ndef getBlankCipherletterMapping():\n    # Returns a dictionary value that is a blank cipherletter mapping.\n    return {\'A\': [], \'B\': [], \'C\': [], \'D\': [], \'E\': [], \'F\': [], \'G\': [], \'H\': [], \'I\': [], \'J\': [], \'K\': [], \'L\': [], \'M\': [], \'N\': [], \'O\': [], \'P\': [], \'Q\': [], \'R\': [], \'S\': [], \'T\': [], \'U\': [], \'V\': [], \'W\': [], \'X\': [], \'Y\': [], \'Z\': []}\n\n\ndef addLettersToMapping(letterMapping, cipherword, candidate):\n    # The letterMapping parameter is a \"cipherletter mapping\" dictionary\n    # value that the return value of this function starts as a copy of.\n    # The cipherword parameter is a string value of the ciphertext word.\n    # The candidate parameter is a possible English word that the\n    # cipherword could decrypt to.\n\n    # This function adds the letters of the candidate as potential\n    # decryption letters for the cipherletters in the cipherletter\n    # mapping.\n\n    letterMapping = copy.deepcopy(letterMapping)\n    for i in range(len(cipherword)):\n        if candidate[i] not in letterMapping[cipherword[i]]:\n            letterMapping[cipherword[i]].append(candidate[i])\n    return letterMapping\n\n\ndef intersectMappings(mapA, mapB):\n    # To intersect two maps, create a blank map, and then add only the\n    # potential decryption letters if they exist in BOTH maps.\n    intersectedMapping = getBlankCipherletterMapping()\n    for letter in LETTERS:\n\n        # An empty list means \"any letter is possible\". In this case just\n        # copy the other map entirely.\n        if mapA[letter] == []:\n            intersectedMapping[letter] = copy.deepcopy(mapB[letter])\n        elif mapB[letter] == []:\n            intersectedMapping[letter] = copy.deepcopy(mapA[letter])\n        else:\n            # If a letter in mapA[letter] exists in mapB[letter], add\n            # that letter to intersectedMapping[letter].\n            for mappedLetter in mapA[letter]:\n                if mappedLetter in mapB[letter]:\n                    intersectedMapping[letter].append(mappedLetter)\n\n    return intersectedMapping\n\n\ndef removeSolvedLettersFromMapping(letterMapping):\n    # Cipher letters in the mapping that map to only one letter are\n    # \"solved\" and can be removed from the other letters.\n    # For example, if \'A\' maps to potential letters [\'M\', \'N\'], and \'B\'\n    # maps to [\'N\'], then we know that \'B\' must map to \'N\', so we can\n    # remove \'N\' from the list of what \'A\' could map to. So \'A\' then maps\n    # to [\'M\']. Note that now that \'A\' maps to only one letter, we can\n    # remove \'M\' from the list of letters for every other\n    # letter. (This is why there is a loop that keeps reducing the map.)\n    letterMapping = copy.deepcopy(letterMapping)\n    loopAgain = True\n    while loopAgain:\n        # First assume that we will not loop again:\n        loopAgain = False\n\n        # solvedLetters will be a list of uppercase letters that have one\n        # and only one possible mapping in letterMapping\n        solvedLetters = []\n        for cipherletter in LETTERS:\n            if len(letterMapping[cipherletter]) == 1:\n                solvedLetters.append(letterMapping[cipherletter][0])\n\n        # If a letter is solved, than it cannot possibly be a potential\n        # decryption letter for a different ciphertext letter, so we\n        # should remove it from those other lists.\n        for cipherletter in LETTERS:\n            for s in solvedLetters:\n                if len(letterMapping[cipherletter]) != 1 and s in letterMapping[cipherletter]:\n                    letterMapping[cipherletter].remove(s)\n                    if len(letterMapping[cipherletter]) == 1:\n                        # A new letter is now solved, so loop again.\n                        loopAgain = True\n    return letterMapping\n\n\ndef hackSimpleSub(message):\n    intersectedMap = getBlankCipherletterMapping()\n    cipherwordList = nonLettersOrSpacePattern.sub(\'\', message.upper()).split()\n    for cipherword in cipherwordList:\n        # Get a new cipherletter mapping for each ciphertext word.\n        newMap = getBlankCipherletterMapping()\n\n        wordPattern = makeWordPatterns.getWordPattern(cipherword)\n        if wordPattern not in wordPatterns.allPatterns:\n            continue # This word was not in our dictionary, so continue.\n\n        # Add the letters of each candidate to the mapping.\n        for candidate in wordPatterns.allPatterns[wordPattern]:\n            newMap = addLettersToMapping(newMap, cipherword, candidate)\n\n        # Intersect the new mapping with the existing intersected mapping.\n        intersectedMap = intersectMappings(intersectedMap, newMap)\n\n    # Remove any solved letters from the other lists.\n    return removeSolvedLettersFromMapping(intersectedMap)\n\n\ndef decryptWithCipherletterMapping(ciphertext, letterMapping):\n    # Return a string of the ciphertext decrypted with the letter mapping,\n    # with any ambiguous decrypted letters replaced with an _ underscore.\n\n    # First create a simple sub key from the letterMapping mapping.\n    key = [\'x\'] * len(LETTERS)\n    for cipherletter in LETTERS:\n        if len(letterMapping[cipherletter]) == 1:\n            # If there\'s only one letter, add it to the key.\n            keyIndex = LETTERS.find(letterMapping[cipherletter][0])\n            key[keyIndex] = cipherletter\n        else:\n            ciphertext = ciphertext.replace(cipherletter.lower(), \'_\')\n            ciphertext = ciphertext.replace(cipherletter.upper(), \'_\')\n    key = \'\'.join(key)\n\n    # With the key we\'ve created, decrypt the ciphertext.\n    return simpleSubCipher.decryptMessage(key, ciphertext)\n\n\nif __name__ == \'__main__\':\n    main()",
    "simpleSubDictionaryHacker": "# Simple Substitution Dictionary Hacker, http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\nimport pyperclip, simpleSubKeyword, detectEnglish\n\nSILENT_MODE = False\n\ndef main():\n    myMessage = r\"\"\"SJITDOPIQR: JIR RIQMUNQRO AY P WDQC QCR NRSMRQN JT A SJITDORO QJ CRMNRGT AY S. -PHAMJNR ADRMSR\"\"\"\n\n    brokenCiphertext = hackSimpleSubDictionary(myMessage)\n\n    if brokenCiphertext == None:\n        # hackSimpleSubDictionary() will return the None value if it was unable to hack the encryption.\n        print(\'Hacking failed. Unable to hack this ciphertext.\')\n    else:\n        # The plaintext is displayed on the screen. For the convenience of the user, we copy the text of the code to the clipboard.\n        print(\'Copying broken ciphertext to clipboard:\')\n        print(brokenCiphertext)\n        pyperclip.copy(brokenCiphertext)\n\n\ndef hackSimpleSubDictionary(message):\n    print(\'Hacking with %s possible dictionary words...\' % (len(detectEnglish.ENGLISH_WORDS) * 3))\n\n    # Python programs can be stopped at any time by pressing Ctrl-C (on Windows) or Ctrl-D (on Mac and Linux)\n    print(\'(Press Ctrl-C or Ctrl-D to quit at any time.)\')\n\n    tryNum = 1\n\n    # brute-force by looping through every possible key\n    for key in detectEnglish.ENGLISH_WORDS:\n        if tryNum % 100 == 0 and not SILENT_MODE:\n            print(\'%s keys tried. (%s)\' % (tryNum, key))\n\n        decryptedText = simpleSubKeyword.decryptMessage(key, message)\n\n        if detectEnglish.getEnglishCount(decryptedText) \x3E 0.20:\n            # Check with the user to see if the decrypted key has been found.\n            print()\n            print(\'Possible encryption hack:\')\n            print(\'Key: \' + str(key))\n            print(\'Decrypted message: \' + decryptedText[:100])\n            print()\n            print(\'Enter D for done, or just press Enter to continue hacking:\')\n            response = input(\'\x3E \')\n\n            if response.upper().startswith(\'D\'):\n                return decryptedText\n\n        tryNum += 1\n    return None\n\nif __name__ == \'__main__\':\n    main()",
    "simpleSubCipher": "# Simple Substitution Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip, sys, random\n\n\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\ndef main():\n    myMessage = \'If a man is offered a fact which goes against his instincts, he will scrutinize it closely, and unless the evidence is overwhelming, he will refuse to believe it. If, on the other hand, he is offered something which affords a reason for acting in accordance to his instincts, he will accept it even on the slightest evidence. The origin of myths is explained in this way. -Bertrand Russell\'\n    myKey = \'LFWOAYUISVKMNXPBDCRJTQEGHZ\'\n    myMode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n    checkValidKey(myKey)\n\n    if myMode == \'encrypt\':\n        translated = encryptMessage(myKey, myMessage)\n    elif myMode == \'decrypt\':\n        translated = decryptMessage(myKey, myMessage)\n    print(\'Using key %s\' % (myKey))\n    print(\'The %sed message is:\' % (myMode))\n    print(translated)\n    pyperclip.copy(translated)\n    print()\n    print(\'This message has been copied to the clipboard.\')\n\n\ndef checkValidKey(key):\n    keyList = list(key)\n    lettersList = list(LETTERS)\n    keyList.sort()\n    lettersList.sort()\n    if keyList != lettersList:\n        sys.exit(\'There is an error in the key or symbol set.\')\n\n\ndef encryptMessage(key, message):\n    return translateMessage(key, message, \'encrypt\')\n\n\ndef decryptMessage(key, message):\n    return translateMessage(key, message, \'decrypt\')\n\n\ndef translateMessage(key, message, mode):\n    translated = \'\'\n    charsA = LETTERS\n    charsB = key\n    if mode == \'decrypt\':\n        # For decrypting, we can use the same code as encrypting. We\n        # just need to swap where the key and LETTERS strings are used.\n        charsA, charsB = charsB, charsA\n\n    # loop through each symbol in the message\n    for symbol in message:\n        if symbol.upper() in charsA:\n            # encrypt\x2Fdecrypt the symbol\n            symIndex = charsA.find(symbol.upper())\n            if symbol.isupper():\n                translated += charsB[symIndex].upper()\n            else:\n                translated += charsB[symIndex].lower()\n        else:\n            # symbol is not in LETTERS, just add it\n            translated += symbol\n\n    return translated\n\n\ndef getRandomKey():\n    key = list(LETTERS)\n    random.shuffle(key)\n    return \'\'.join(key)\n\n\nif __name__ == \'__main__\':\n    main()",
    "rsaCipher": "# RSA Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport sys\n\n# IMPORTANT: The block size MUST be less than or equal to the key size!\n# (Note: The block size is in bytes, the key size is in bits. There\n# are 8 bits in 1 byte.)\nDEFAULT_BLOCK_SIZE = 128 # 128 bytes\nBYTE_SIZE = 256 # One byte has 256 different values.\n\ndef main():\n    # Runs a test that encrypts a message to a file or decrypts a message\n    # from a file.\n    filename = \'encrypted_file.txt\' # the file to write to\x2Fread from\n    mode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n    if mode == \'encrypt\':\n        message = \'\'\'\"Journalists belong in the gutter because that is where the ruling classes throw their guilty secrets.\" -Gerald Priestland \"The Founding Fathers gave the free press the protection it must have to bare the secrets of government and inform the people.\" -Hugo Black\'\'\'\n        pubKeyFilename = \'al_sweigart_pubkey.txt\'\n        print(\'Encrypting and writing to %s...\' % (filename))\n        encryptedText = encryptAndWriteToFile(filename, pubKeyFilename, message)\n\n        print(\'Encrypted text:\')\n        print(encryptedText)\n\n    elif mode == \'decrypt\':\n        privKeyFilename = \'al_sweigart_privkey.txt\'\n        print(\'Reading from %s and decrypting...\' % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n\n        print(\'Decrypted text:\')\n        print(decryptedText)\n\n\ndef getBlocksFromText(message, blockSize=DEFAULT_BLOCK_SIZE):\n    # Converts a string message to a list of block integers. Each integer\n    # represents 128 (or whatever blockSize is set to) string characters.\n\n    messageBytes = message.encode(\'ascii\') # convert the string to bytes\n\n    blockInts = []\n    for blockStart in range(0, len(messageBytes), blockSize):\n        # Calculate the block integer for this block of text\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(messageBytes))):\n            blockInt += messageBytes[i] * (BYTE_SIZE ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(blockInts, messageLength, blockSize=DEFAULT_BLOCK_SIZE):\n    # Converts a list of block integers to the original message string.\n    # The original message length is needed to properly convert the last\n    # block integer.\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i \x3C messageLength:\n                # Decode the message string for the 128 (or whatever\n                # blockSize is set to) characters from this block integer.\n                asciiNumber = blockInt \x2F\x2F (BYTE_SIZE ** i)\n                blockInt = blockInt % (BYTE_SIZE ** i)\n                blockMessage.insert(0, chr(asciiNumber))\n        message.extend(blockMessage)\n    return \'\'.join(message)\n\n\ndef encryptMessage(message, key, blockSize=DEFAULT_BLOCK_SIZE):\n    # Converts the message string into a list of block integers, and then\n    # encrypts each block integer. Pass the PUBLIC key to encrypt.\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        # ciphertext = plaintext ^ e mod n\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(encryptedBlocks, messageLength, key, blockSize=DEFAULT_BLOCK_SIZE):\n    # Decrypts a list of encrypted block ints into the original message\n    # string. The original message length is required to properly decrypt\n    # the last block. Be sure to pass the PRIVATE key to decrypt.\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        # plaintext = ciphertext ^ d mod n\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename):\n    # Given the filename of a file that contains a public or private key,\n    # return the key as a (n,e) or (n,d) tuple value.\n    fo = open(keyFilename)\n    content = fo.read()\n    fo.close()\n    keySize, n, EorD = content.split(\',\')\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(messageFilename, keyFilename, message, blockSize=DEFAULT_BLOCK_SIZE):\n    # Using a key from a key file, encrypt the message and save it to a\n    # file. Returns the encrypted message string.\n    keySize, n, e = readKeyFile(keyFilename)\n\n    # Check that key size is greater than block size.\n    if keySize \x3C blockSize * 8: # * 8 to convert bytes to bits\n        sys.exit(\'ERROR: Block size is %s bits and key size is %s bits. The RSA cipher requires the block size to be equal to or less than the key size. Either decrease the block size or use different keys.\' % (blockSize * 8, keySize))\n\n\n    # Encrypt the message\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    # Convert the large int values to one string value.\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \',\'.join(encryptedBlocks)\n\n    # Write out the encrypted string to the output file.\n    encryptedContent = \'%s_%s_%s\' % (len(message), blockSize, encryptedContent)\n    fo = open(messageFilename, \'w\')\n    fo.write(encryptedContent)\n    fo.close()\n    # Also return the encrypted string.\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename, keyFilename):\n    # Using a key from a key file, read an encrypted message from a file\n    # and then decrypt it. Returns the decrypted message string.\n    keySize, n, d = readKeyFile(keyFilename)\n\n\n    # Read in the message length and the encrypted message from the file.\n    fo = open(messageFilename)\n    content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\'_\')\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    # Check that key size is greater than block size.\n    if keySize \x3C blockSize * 8: # * 8 to convert bytes to bits\n        sys.exit(\'ERROR: Block size is %s bits and key size is %s bits. The RSA cipher requires the block size to be equal to or less than the key size. Did you specify the correct key file and encrypted file?\' % (blockSize * 8, keySize))\n\n    # Convert the encrypted message into large int values.\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\',\'):\n        encryptedBlocks.append(int(block))\n\n    # Decrypt the large int values.\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n\n# If rsaCipher.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "reverseCipher": "# Reverse Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nmessage = \'Three can keep a secret, if two of them are dead.\'\ntranslated = \'\'\n\ni = len(message) - 1\nwhile i \x3E= 0:\n    translated = translated + message[i]\n    i = i - 1\n\nprint(translated)",
    "rabinMiller": "# Primality Testing with the Rabin-Miller Algorithm\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport random\n\n\ndef rabinMiller(num):\n    # Returns True if num is a prime number.\n\n    s = num - 1\n    t = 0\n    while s % 2 == 0:\n        # keep halving s while it is even (and use t\n        # to count how many times we halve s)\n        s = s \x2F\x2F 2\n        t += 1\n\n    for trials in range(5): # try to falsify num\'s primality 5 times\n        a = random.randrange(2, num - 1)\n        v = pow(a, s, num)\n        if v != 1: # this test does not apply if v is 1.\n            i = 0\n            while v != (num - 1):\n                if i == t - 1:\n                    return False\n                else:\n                    i = i + 1\n                    v = (v ** 2) % num\n    return True\n\n\ndef isPrime(num):\n    # Return True if num is a prime number. This function does a quicker\n    # prime number check before calling rabinMiller().\n\n    if (num \x3C 2):\n        return False # 0, 1, and negative numbers are not prime\n\n    # About 1\x2F3 of the time we can quickly determine if num is not prime\n    # by dividing by the first few dozen prime numbers. This is quicker\n    # than rabinMiller(), but unlike rabinMiller() is not guaranteed to\n    # prove that a number is prime.\n    lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n\n    if num in lowPrimes:\n        return True\n\n    # See if any of the low prime numbers can divide num\n    for prime in lowPrimes:\n        if (num % prime == 0):\n            return False\n\n    # If all else fails, call rabinMiller() to determine if num is a prime.\n    return rabinMiller(num)\n\n\ndef generateLargePrime(keysize=1024):\n    # Return a random prime number of keysize bits in size.\n    while True:\n        num = random.randrange(2**(keysize-1), 2**(keysize))\n        if isPrime(num):\n            return num",
    "primeSieve": "# Prime Number Sieve\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport math\n\n\ndef isPrime(num):\n    # Returns True if num is a prime number, otherwise False.\n\n    # Note: Generally, isPrime() is slower than primeSieve().\n\n    # all numbers less than 2 are not prime\n    if num \x3C 2:\n        return False\n\n    # see if num is divisible by any number up to the square root of num\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n\ndef primeSieve(sieveSize):\n    # Returns a list of prime numbers calculated using\n    # the Sieve of Eratosthenes algorithm.\n\n    sieve = [True] * sieveSize\n    sieve[0] = False # zero and one are not prime numbers\n    sieve[1] = False\n\n    # create the sieve\n    for i in range(2, int(math.sqrt(sieveSize)) + 1):\n        pointer = i * 2\n        while pointer \x3C sieveSize:\n            sieve[pointer] = False\n            pointer += i\n\n    # compile the list of primes\n    primes = []\n    for i in range(sieveSize):\n        if sieve[i] == True:\n            primes.append(i)\n\n    return primes\n",
    "makeWordPatterns": "# Makes the wordPatterns.py File\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\n# Creates wordPatterns.py based on the words in our dictionary\n# text file, dictionary.txt. (Download this file from\n# http:\x2F\x2Finvpy.com\x2Fdictionary.txt)\n\nimport pprint\n\n\ndef getWordPattern(word):\n    # Returns a string of the pattern form of the given word.\n    # e.g. \'0.1.2.3.4.1.2.3.5.6\' for \'DUSTBUSTER\'\n    word = word.upper()\n    nextNum = 0\n    letterNums = {}\n    wordPattern = []\n\n    for letter in word:\n        if letter not in letterNums:\n            letterNums[letter] = str(nextNum)\n            nextNum += 1\n        wordPattern.append(letterNums[letter])\n    return \'.\'.join(wordPattern)\n\n\ndef main():\n    allPatterns = {}\n\n    fo = open(\'dictionary.txt\')\n    wordList = fo.read().split(\'\\n\')\n    fo.close()\n\n    for word in wordList:\n        # Get the pattern for each string in wordList.\n        pattern = getWordPattern(word)\n\n        if pattern not in allPatterns:\n            allPatterns[pattern] = [word]\n        else:\n            allPatterns[pattern].append(word)\n\n    # This is code that writes code. The wordPatterns.py file contains\n    # one very, very large assignment statement.\n    fo = open(\'wordPatterns.py\', \'w\')\n    fo.write(\'allPatterns = \')\n    fo.write(pprint.pformat(allPatterns))\n    fo.close()\n\n\nif __name__ == \'__main__\':\n    main()",
    "makeRsaKeys": "# RSA Key Generator\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport random, sys, os, rabinMiller, cryptomath\n\n\ndef main():\n    # create a public\x2Fprivate keypair with 1024 bit keys\n    print(\'Making key files...\')\n    makeKeyFiles(\'al_sweigart\', 1024)\n    print(\'Key files made.\')\n\ndef generateKey(keySize):\n    # Creates a public\x2Fprivate key pair with keys that are keySize bits in\n    # size. This function may take a while to run.\n\n    # Step 1: Create two prime numbers, p and q. Calculate n = p * q.\n    print(\'Generating p prime...\')\n    p = rabinMiller.generateLargePrime(keySize)\n    print(\'Generating q prime...\')\n    q = rabinMiller.generateLargePrime(keySize)\n    n = p * q\n\n    # Step 2: Create a number e that is relatively prime to (p-1)*(q-1).\n    print(\'Generating e that is relatively prime to (p-1)*(q-1)...\')\n    while True:\n        # Keep trying random numbers for e until one is valid.\n        e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))\n        if cryptomath.gcd(e, (p - 1) * (q - 1)) == 1:\n            break\n\n    # Step 3: Calculate d, the mod inverse of e.\n    print(\'Calculating d that is mod inverse of e...\')\n    d = cryptomath.findModInverse(e, (p - 1) * (q - 1))\n\n    publicKey = (n, e)\n    privateKey = (n, d)\n\n    print(\'Public key:\', publicKey)\n    print(\'Private key:\', privateKey)\n\n    return (publicKey, privateKey)\n\n\ndef makeKeyFiles(name, keySize):\n    # Creates two files \'x_pubkey.txt\' and \'x_privkey.txt\' (where x is the\n    # value in name) with the the n,e and d,e integers written in them,\n    # delimited by a comma.\n\n    # Our safety check will prevent us from overwriting our old key files:\n    if os.path.exists(\'%s_pubkey.txt\' % (name)) or os.path.exists(\'%s_privkey.txt\' % (name)):\n        sys.exit(\'WARNING: The file %s_pubkey.txt or %s_privkey.txt already exists! Use a different name or delete these files and re-run this program.\' % (name, name))\n\n    publicKey, privateKey = generateKey(keySize)\n\n    print()\n    print(\'The public key is a %s and a %s digit number.\' % (len(str(publicKey[0])), len(str(publicKey[1]))))\n    print(\'Writing public key to file %s_pubkey.txt...\' % (name))\n    fo = open(\'%s_pubkey.txt\' % (name), \'w\')\n    fo.write(\'%s,%s,%s\' % (keySize, publicKey[0], publicKey[1]))\n    fo.close()\n\n    print()\n    print(\'The private key is a %s and a %s digit number.\' % (len(str(publicKey[0])), len(str(publicKey[1]))))\n    print(\'Writing private key to file %s_privkey.txt...\' % (name))\n    fo = open(\'%s_privkey.txt\' % (name), \'w\')\n    fo.write(\'%s,%s,%s\' % (keySize, privateKey[0], privateKey[1]))\n    fo.close()\n\n\n# If makeRsaKeys.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "freqAnalysis": "# Frequency Finder\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\n\n\n# frequency taken from http:\x2F\x2Fen.wikipedia.org\x2Fwiki\x2FLetter_frequency\nenglishLetterFreq = {\'E\': 12.70, \'T\': 9.06, \'A\': 8.17, \'O\': 7.51, \'I\': 6.97, \'N\': 6.75, \'S\': 6.33, \'H\': 6.09, \'R\': 5.99, \'D\': 4.25, \'L\': 4.03, \'C\': 2.78, \'U\': 2.76, \'M\': 2.41, \'W\': 2.36, \'F\': 2.23, \'G\': 2.02, \'Y\': 1.97, \'P\': 1.93, \'B\': 1.29, \'V\': 0.98, \'K\': 0.77, \'J\': 0.15, \'X\': 0.15, \'Q\': 0.10, \'Z\': 0.07}\nETAOIN = \'ETAOINSHRDLCUMWFGYPBVKJXQZ\'\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\n\n\ndef getLetterCount(message):\n    # Returns a dictionary with keys of single letters and values of the\n    # count of how many times they appear in the message parameter.\n    letterCount = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'E\': 0, \'F\': 0, \'G\': 0, \'H\': 0, \'I\': 0, \'J\': 0, \'K\': 0, \'L\': 0, \'M\': 0, \'N\': 0, \'O\': 0, \'P\': 0, \'Q\': 0, \'R\': 0, \'S\': 0, \'T\': 0, \'U\': 0, \'V\': 0, \'W\': 0, \'X\': 0, \'Y\': 0, \'Z\': 0}\n\n    for letter in message.upper():\n        if letter in LETTERS:\n            letterCount[letter] += 1\n\n    return letterCount\n\n\ndef getItemAtIndexZero(x):\n    return x[0]\n\n\ndef getFrequencyOrder(message):\n    # Returns a string of the alphabet letters arranged in order of most\n    # frequently occurring in the message parameter.\n\n    # first, get a dictionary of each letter and its frequency count\n    letterToFreq = getLetterCount(message)\n\n    # second, make a dictionary of each frequency count to each letter(s)\n    # with that frequency\n    freqToLetter = {}\n    for letter in LETTERS:\n        if letterToFreq[letter] not in freqToLetter:\n            freqToLetter[letterToFreq[letter]] = [letter]\n        else:\n            freqToLetter[letterToFreq[letter]].append(letter)\n\n    # third, put each list of letters in reverse \"ETAOIN\" order, and then\n    # convert it to a string\n    for freq in freqToLetter:\n        freqToLetter[freq].sort(key=ETAOIN.find, reverse=True)\n        freqToLetter[freq] = \'\'.join(freqToLetter[freq])\n\n    # fourth, convert the freqToLetter dictionary to a list of tuple\n    # pairs (key, value), then sort them\n    freqPairs = list(freqToLetter.items())\n    freqPairs.sort(key=getItemAtIndexZero, reverse=True)\n\n    # fifth, now that the letters are ordered by frequency, extract all\n    # the letters for the final string\n    freqOrder = []\n    for freqPair in freqPairs:\n        freqOrder.append(freqPair[1])\n\n    return \'\'.join(freqOrder)\n\n\ndef englishFreqMatchScore(message):\n    # Return the number of matches that the string in the message\n    # parameter has when its letter frequency is compared to English\n    # letter frequency. A \"match\" is how many of its six most frequent\n    # and six least frequent letters is among the six most frequent and\n    # six least frequent letters for English.\n    freqOrder = getFrequencyOrder(message)\n\n    matchScore = 0\n    # Find how many matches for the six most common letters there are.\n    for commonLetter in ETAOIN[:6]:\n        if commonLetter in freqOrder[:6]:\n            matchScore += 1\n    # Find how many matches for the six least common letters there are.\n    for uncommonLetter in ETAOIN[-6:]:\n        if uncommonLetter in freqOrder[-6:]:\n            matchScore += 1\n\n    return matchScore",
    "detectEnglish": "# Detect English module\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# http:\x2F\x2Finvpy.com\x2Fdictionary.txt)\nUPPERLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + \' \\t\\n\'\n\ndef loadDictionary():\n    dictionaryFile = open(\'dictionary.txt\')\n    englishWords = {}\n    for word in dictionaryFile.read().split(\'\\n\'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # no words at all, so return 0.0\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) \x2F len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return \'\'.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 \x3E= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) \x2F len(message) * 100\n    lettersMatch = messageLettersPercentage \x3E= letterPercentage\n    return wordsMatch and lettersMatch",
    "cryptomath": "# Cryptomath Module\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\ndef gcd(a, b):\n    # Return the GCD of a and b using Euclid\'s Algorithm\n    while a != 0:\n        a, b = b % a, a\n    return b\n\n\ndef findModInverse(a, m):\n    # Returns the modular inverse of a % m, which is\n    # the number x such that a*x % m = 1\n\n    if gcd(a, m) != 1:\n        return None # no mod inverse if a \& m aren\'t relatively prime\n\n    # Calculate using the Extended Euclidean Algorithm:\n    u1, u2, u3 = 1, 0, a\n    v1, v2, v3 = 0, 1, m\n    while v3 != 0:\n        q = u3 \x2F\x2F v3 # \x2F\x2F is the integer division operator\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n    return u1 % m",
    "caesarHacker": "# Caesar Cipher Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nmessage = \'GUVF VF ZL FRPERG ZRFFNTR.\'\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\n# loop through every possible key\nfor key in range(len(LETTERS)):\n\n    # It is important to set translated to the blank string so that the\n    # previous iteration\'s value for translated is cleared.\n    translated = \'\'\n\n    # The rest of the program is the same as the original Caesar program:\n\n    # run the encryption\x2Fdecryption code on each symbol in the message\n    for symbol in message:\n        if symbol in LETTERS:\n            num = LETTERS.find(symbol) # get the number of the symbol\n            num = num - key\n\n            # handle the wrap-around if num is 26 or larger or less than 0\n            if num \x3C 0:\n                num = num + len(LETTERS)\n\n            # add number\'s symbol at the end of translated\n            translated = translated + LETTERS[num]\n\n        else:\n            # just add the symbol without encrypting\x2Fdecrypting\n            translated = translated + symbol\n\n    # display the current key being tested, along with its decryption\n    print(\'Key #%s: %s\' % (key, translated))",
    "caesarCipher": "# Caesar Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip\n\n# the string to be encrypted\x2Fdecrypted\nmessage = \'This is my secret message.\'\n\n# the encryption\x2Fdecryption key\nkey = 13\n\n# tells the program to encrypt or decrypt\nmode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n# every possible symbol that can be encrypted\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\n# stores the encrypted\x2Fdecrypted form of the message\ntranslated = \'\'\n\n# capitalize the string in message\nmessage = message.upper()\n\n# run the encryption\x2Fdecryption code on each symbol in the message string\nfor symbol in message:\n    if symbol in LETTERS:\n        # get the encrypted (or decrypted) number for this symbol\n        num = LETTERS.find(symbol) # get the number of the symbol\n        if mode == \'encrypt\':\n            num = num + key\n        elif mode == \'decrypt\':\n            num = num - key\n\n        # handle the wrap-around if num is larger than the length of\n        # LETTERS or less than 0\n        if num \x3E= len(LETTERS):\n            num = num - len(LETTERS)\n        elif num \x3C 0:\n            num = num + len(LETTERS)\n\n        # add encrypted\x2Fdecrypted number\'s symbol at the end of translated\n        translated = translated + LETTERS[num]\n\n    else:\n        # just add the symbol without encrypting\x2Fdecrypting\n        translated = translated + symbol\n\n# print the encrypted\x2Fdecrypted string to the screen\nprint(translated)\n\n# copy the encrypted\x2Fdecrypted string to the clipboard\npyperclip.copy(translated)",
    "caesarCipher2": "# Caesar Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip\n\n# the string to be encrypted\x2Fdecrypted\nmessage = \'This is my secret message.\'\n\n# the encryption\x2Fdecryption key\nkey = 13\n\n# tells the program to encrypt or decrypt\nmode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n# every possible symbol that can be encrypted\nLETTERS = \' !\"#$%\&\\\'()*+,-.\x2F0123456789:;\x3C=\x3E?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\'\n\n# stores the encrypted\x2Fdecrypted form of the message\ntranslated = \'\'\n\n# capitalize the string in message\n#message = message.upper()\n\n# run the encryption\x2Fdecryption code on each symbol in the message string\nfor symbol in message:\n    if symbol in LETTERS:\n        # get the encrypted (or decrypted) number for this symbol\n        num = LETTERS.find(symbol) # get the number of the symbol\n        if mode == \'encrypt\':\n            num = num + key\n        elif mode == \'decrypt\':\n            num = num - key\n\n        # handle the wrap-around if num is larger than the length of\n        # LETTERS or less than 0\n        if num \x3E= len(LETTERS):\n            num = num - len(LETTERS)\n        elif num \x3C 0:\n            num = num + len(LETTERS)\n\n        # add encrypted\x2Fdecrypted number\'s symbol at the end of translated\n        translated = translated + LETTERS[num]\n\n    else:\n        # just add the symbol without encrypting\x2Fdecrypting\n        translated = translated + symbol\n\n# print the encrypted\x2Fdecrypted string to the screen\nprint(translated)\n\n# copy the encrypted\x2Fdecrypted string to the clipboard\npyperclip.copy(translated)",
    "affineKeyTest": "# This program proves that the keyspace of the affine cipher is limited\n# to len(SYMBOLS) ^ 2.\n\nimport affineCipher, cryptomath\n\nmessage = \'Make things as simple as possible, but not simpler.\'\nfor keyA in range(2, 100):\n    key = keyA * len(affineCipher.SYMBOLS) + 1\n\n    if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) == 1:\n        print(keyA, affineCipher.encryptMessage(key, message))",
    "affineHacker": "# Affine Cipher Hacker\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport pyperclip, affineCipher, detectEnglish, cryptomath\n\nSILENT_MODE = False\n\ndef main():\n    # You might want to copy \& paste this text from the source code at\n    # http:\x2F\x2Finvpy.com\x2FaffineHacker.py\n    myMessage = \"\"\"U\&\'\x3C3dJ^Gjx\'-3^MS\'Sj0jxuj\'G3\'%j\'\x3CmMMjS\'g{GjMMg9j{G\'g\"\'gG\'\x3C3^MS\'Sj\x3Cjguj\'m\'P^dm{\'g{G3\'%jMgjug{9\'GPmG\'gG\'-m0\'P^dm{LU\'5\&Mm{\'_^xg{9\"\"\"\n\n    hackedMessage = hackAffine(myMessage)\n\n    if hackedMessage != None:\n        # The plaintext is displayed on the screen. For the convenience of\n        # the user, we copy the text of the code to the clipboard.\n        print(\'Copying hacked message to clipboard:\')\n        print(hackedMessage)\n        pyperclip.copy(hackedMessage)\n    else:\n        print(\'Failed to hack encryption.\')\n\n\ndef hackAffine(message):\n    print(\'Hacking...\')\n\n    # Python programs can be stopped at any time by pressing Ctrl-C (on\n    # Windows) or Ctrl-D (on Mac and Linux)\n    print(\'(Press Ctrl-C or Ctrl-D to quit at any time.)\')\n\n    # brute-force by looping through every possible key\n    for key in range(len(affineCipher.SYMBOLS) ** 2):\n        keyA = affineCipher.getKeyParts(key)[0]\n        if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) != 1:\n            continue\n\n        decryptedText = affineCipher.decryptMessage(key, message)\n        if not SILENT_MODE:\n            print(\'Tried Key %s... (%s)\' % (key, decryptedText[:40]))\n\n        if detectEnglish.isEnglish(decryptedText):\n            # Check with the user if the decrypted key has been found.\n            print()\n            print(\'Possible encryption hack:\')\n            print(\'Key: %s\' % (key))\n            print(\'Decrypted message: \' + decryptedText[:200])\n            print()\n            print(\'Enter D for done, or just press Enter to continue hacking:\')\n            response = input(\'\x3E \')\n\n            if response.strip().upper().startswith(\'D\'):\n                return decryptedText\n    return None\n\n\n# If affineHacker.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "affineCipher": "# Affine Cipher\n# http:\x2F\x2Finventwithpython.com\x2Fhacking (BSD Licensed)\n\nimport sys, pyperclip, cryptomath, random\nSYMBOLS = \"\"\" !\"#$%\&\'()*+,-.\x2F0123456789:;\x3C=\x3E?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\"\" # note the space at the front\n\n\ndef main():\n    myMessage = \"\"\"\"A computer would deserve to be called intelligent if it could deceive a human into believing that it was human.\" -Alan Turing\"\"\"\n    myKey = 2023\n    myMode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n    if myMode == \'encrypt\':\n        translated = encryptMessage(myKey, myMessage)\n    elif myMode == \'decrypt\':\n        translated = decryptMessage(myKey, myMessage)\n    print(\'Key: %s\' % (myKey))\n    print(\'%sed text:\' % (myMode.title()))\n    print(translated)\n    pyperclip.copy(translated)\n    print(\'Full %sed text copied to clipboard.\' % (myMode))\n\n\ndef getKeyParts(key):\n    keyA = key \x2F\x2F len(SYMBOLS)\n    keyB = key % len(SYMBOLS)\n    return (keyA, keyB)\n\n\ndef checkKeys(keyA, keyB, mode):\n    if keyA == 1 and mode == \'encrypt\':\n        sys.exit(\'The affine cipher becomes incredibly weak when key A is set to 1. Choose a different key.\')\n    if keyB == 0 and mode == \'encrypt\':\n        sys.exit(\'The affine cipher becomes incredibly weak when key B is set to 0. Choose a different key.\')\n    if keyA \x3C 0 or keyB \x3C 0 or keyB \x3E len(SYMBOLS) - 1:\n        sys.exit(\'Key A must be greater than 0 and Key B must be between 0 and %s.\' % (len(SYMBOLS) - 1))\n    if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:\n        sys.exit(\'Key A (%s) and the symbol set size (%s) are not relatively prime. Choose a different key.\' % (keyA, len(SYMBOLS)))\n\n\ndef encryptMessage(key, message):\n    keyA, keyB = getKeyParts(key)\n    checkKeys(keyA, keyB, \'encrypt\')\n    ciphertext = \'\'\n    for symbol in message:\n        if symbol in SYMBOLS:\n            # encrypt this symbol\n            symIndex = SYMBOLS.find(symbol)\n            ciphertext += SYMBOLS[(symIndex * keyA + keyB) % len(SYMBOLS)]\n        else:\n            ciphertext += symbol # just append this symbol unencrypted\n    return ciphertext\n\n\ndef decryptMessage(key, message):\n    keyA, keyB = getKeyParts(key)\n    checkKeys(keyA, keyB, \'decrypt\')\n    plaintext = \'\'\n    modInverseOfKeyA = cryptomath.findModInverse(keyA, len(SYMBOLS))\n\n    for symbol in message:\n        if symbol in SYMBOLS:\n            # decrypt this symbol\n            symIndex = SYMBOLS.find(symbol)\n            plaintext += SYMBOLS[(symIndex - keyB) * modInverseOfKeyA % len(SYMBOLS)]\n        else:\n            plaintext += symbol # just append this symbol undecrypted\n    return plaintext\n\n\ndef getRandomKey():\n    while True:\n        keyA = random.randint(2, len(SYMBOLS))\n        keyB = random.randint(2, len(SYMBOLS))\n        if cryptomath.gcd(keyA, len(SYMBOLS)) == 1:\n            return keyA * len(SYMBOLS) + keyB\n\n\n# If affineCipher.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "hello": "# This program says hello and asks for my name.\nprint(\'Hello world!\')\nprint(\'What is your name?\')\nmyName = input()\nprint(\'It is good to meet you, \' + myName)\n",
    "password": "print(\'What is the password?\')\npassword = input()\nif password == \'rosebud\':\n    print(\'Access granted.\')\nif password != \'rosebud\':\n    print(\'Access denied.\')\nprint(\'Done.\')",
    "password2": "print(\'What is the password?\')\npassword = input()\nif password == \'rosebud\':\n    print(\'Access granted.\')\nelse:\n    print(\'Access denied.\')\nprint(\'Done.\')\n",
    "elifeggs": "numberOfEggs = 12\nif numberOfEggs \x3C 4:\n    print(\'That is not that many eggs.\')\nelif numberOfEggs \x3C 20:\n    print(\'You have quite a few eggs.\')\nelif numberOfEggs == 144:\n    print(\'You have a lot of eggs. Gross!\')\nelse:\n    print(\'Eat ALL the eggs!\')\n",
    "helloFunction": "def hello():\n    print(\'Hello!\')\n    total = 42 + 1\n    print(\'42 plus 1 is %s\' % (total))\nprint(\'Start!\')\nhello()\nprint(\'Call it again.\')\nhello()\nprint(\'Done.\')",
    "nameCount": "def nameCount(name):\n    print(\'Hello %s!\' % (name))\n    print(\'Your name has %s letters in it.\' % (len(name)))\nnameCount(\'Alice\')\nnameCount(\'Bob\')\n",
    "scope": "spam = 42\n\ndef eggs():\n    spam = 99 # spam in this function is local\n    print(\'In eggs():\', spam)\n\ndef ham():\n    print(\'In ham():\', spam) # spam in this function is global\n\ndef bacon():\n    global spam # spam in this function is global\n    print(\'In bacon():\', spam)\n    spam = 0\n\ndef CRASH():\n    print(spam) # spam in this function is local\n    spam = 0\n\nprint(spam)\neggs()\nprint(spam)\nham()\nprint(spam)\nbacon()\nprint(spam)\nCRASH()",
    "addNumbers": "def addNumbers(a, b):\n    return a + b\n\nspam = addNumbers(2, 40)\nprint(spam)"
};
