var sourceCodes = {"AISim1":"# Reversi\n\nimport random\nimport sys\n\ndef drawBoard(board):\n    # This function prints out the board that it was passed. Returns None.\n    HLINE = \'  +---+---+---+---+---+---+---+---+\'\n    VLINE = \'  |   |   |   |   |   |   |   |   |\'\n\n    print(\'    1   2   3   4   5   6   7   8\')\n    print(HLINE)\n    for y in range(8):\n        print(VLINE)\n        print(y+1, end=\' \')\n        for x in range(8):\n            print(\'| %s\' % (board[x][y]), end=\' \')\n        print(\'|\')\n        print(VLINE)\n        print(HLINE)\n\n\ndef resetBoard(board):\n    # Blanks out the board it is passed, except for the original starting position.\n    for x in range(8):\n        for y in range(8):\n            board[x][y] = \' \'\n\n    # Starting pieces:\n    board[3][3] = \'X\'\n    board[3][4] = \'O\'\n    board[4][3] = \'O\'\n    board[4][4] = \'X\'\n\n\ndef getNewBoard():\n    # Creates a brand new, blank board data structure.\n    board = []\n    for i in range(8):\n        board.append([\' \'] * 8)\n\n    return board\n\n\ndef isValidMove(board, tile, xstart, ystart):\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\n        return False\n\n    board[xstart][ystart] = tile # temporarily set the tile on the board.\n\n    if tile == \'X\':\n        otherTile = \'O\'\n    else:\n        otherTile = \'X\'\n\n    tilesToFlip = []\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\n        x, y = xstart, ystart\n        x += xdirection # first step in the direction\n        y += ydirection # first step in the direction\n        if isOnBoard(x, y) and board[x][y] == otherTile:\n            # There is a piece belonging to the other player next to our piece.\n            x += xdirection\n            y += ydirection\n            if not isOnBoard(x, y):\n                continue\n            while board[x][y] == otherTile:\n                x += xdirection\n                y += ydirection\n                if not isOnBoard(x, y): # break out of while loop, then continue in for loop\n                    break\n            if not isOnBoard(x, y):\n                continue\n            if board[x][y] == tile:\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\n                while True:\n                    x -= xdirection\n                    y -= ydirection\n                    if x == xstart and y == ystart:\n                        break\n                    tilesToFlip.append([x, y])\n\n    board[xstart][ystart] = \' \' # restore the empty space\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\n        return False\n    return tilesToFlip\n\n\ndef isOnBoard(x, y):\n    # Returns True if the coordinates are located on the board.\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\n\n\ndef getBoardWithValidMoves(board, tile):\n    # Returns a new board with . marking the valid moves the given player can make.\n    dupeBoard = getBoardCopy(board)\n\n    for x, y in getValidMoves(dupeBoard, tile):\n        dupeBoard[x][y] = \'.\'\n    return dupeBoard\n\n\ndef getValidMoves(board, tile):\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\n    validMoves = []\n\n    for x in range(8):\n        for y in range(8):\n            if isValidMove(board, tile, x, y) != False:\n                validMoves.append([x, y])\n    return validMoves\n\n\ndef getScoreOfBoard(board):\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\n    xscore = 0\n    oscore = 0\n    for x in range(8):\n        for y in range(8):\n            if board[x][y] == \'X\':\n                xscore += 1\n            if board[x][y] == \'O\':\n                oscore += 1\n    return {\'X\':xscore, \'O\':oscore}\n\n\ndef enterPlayerTile():\n    # Let\'s the player type which tile they want to be.\n    # Returns a list with the player\'s tile as the first item, and the computer\'s tile as the second.\n    tile = \'\'\n    while not (tile == \'X\' or tile == \'O\'):\n        print(\'Do you want to be X or O?\')\n        tile = input().upper()\n\n    # the first element in the tuple is the player\'s tile, the second is the computer\'s tile.\n    if tile == \'X\':\n        return [\'X\', \'O\']\n    else:\n        return [\'O\', \'X\']\n\n\ndef whoGoesFirst():\n    # Randomly choose the player who goes first.\n    if random.randint(0, 1) == 0:\n        return \'computer\'\n    else:\n        return \'player\'\n\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\n\ndef makeMove(board, tile, xstart, ystart):\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\n    # Returns False if this is an invalid move, True if it is valid.\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\n\n    if tilesToFlip == False:\n        return False\n\n    board[xstart][ystart] = tile\n    for x, y in tilesToFlip:\n        board[x][y] = tile\n    return True\n\n\ndef getBoardCopy(board):\n    # Make a duplicate of the board list and return the duplicate.\n    dupeBoard = getNewBoard()\n\n    for x in range(8):\n        for y in range(8):\n            dupeBoard[x][y] = board[x][y]\n\n    return dupeBoard\n\n\ndef isOnCorner(x, y):\n    # Returns True if the position is in one of the four corners.\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\n\n\ndef getPlayerMove(board, playerTile):\n    # Let the player type in their move.\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\')\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\n    while True:\n        print(\'Enter your move, or type quit to end the game, or hints to turn off/on hints.\')\n        move = input().lower()\n        if move == \'quit\':\n            return \'quit\'\n        if move == \'hints\':\n            return \'hints\'\n\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\n            x = int(move[0]) - 1\n            y = int(move[1]) - 1\n            if isValidMove(board, playerTile, x, y) == False:\n                continue\n            else:\n                break\n        else:\n            print(\'That is not a valid move. Type the x digit (1-8), then the y digit (1-8).\')\n            print(\'For example, 81 will be the top-right corner.\')\n\n    return [x, y]\n\n\ndef getComputerMove(board, computerTile):\n    # Given a board and the computer\'s tile, determine where to\n    # move and return that move as a [x, y] list.\n    possibleMoves = getValidMoves(board, computerTile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    # Go through all the possible moves and remember the best scoring move\n    bestScore = -1\n    for x, y in possibleMoves:\n        dupeBoard = getBoardCopy(board)\n        makeMove(dupeBoard, computerTile, x, y)\n        score = getScoreOfBoard(dupeBoard)[computerTile]\n        if score > bestScore:\n            bestMove = [x, y]\n            bestScore = score\n    return bestMove\n\n\ndef showPoints(playerTile, computerTile):\n    # Prints out the current score.\n    scores = getScoreOfBoard(mainBoard)\n    print(\'You have %s points. The computer has %s points.\' % (scores[playerTile], scores[computerTile]))\n\n\n\nprint(\'Welcome to Reversi!\')\n\nwhile True:\n    # Reset the board and game.\n    mainBoard = getNewBoard()\n    resetBoard(mainBoard)\n    if whoGoesFirst() == \'player\':\n        turn = \'X\'\n    else:\n         turn = \'O\'\n    print(\'The \' + turn + \' will go first.\')\n\n    while True:\n         drawBoard(mainBoard)\n         scores = getScoreOfBoard(mainBoard)\n         print(\'X has %s points. O has %s points\' % (scores[\'X\'], scores[\'O\']))\n         input(\'Press Enter to continue.\')\n\n         if turn == \'X\':\n              # X\'s turn.\n              otherTile = \'O\'\n              x, y = getComputerMove(mainBoard, \'X\')\n              makeMove(mainBoard, \'X\', x, y)\n         else:\n              # O\'s turn.\n              otherTile = \'X\'\n              x, y = getComputerMove(mainBoard, \'O\')\n              makeMove(mainBoard, \'O\', x, y)\n\n         if getValidMoves(mainBoard, otherTile) == []:\n              break\n         else:\n              turn = otherTile\n\n    # Display the final score.\n    drawBoard(mainBoard)\n    scores = getScoreOfBoard(mainBoard)\n    print(\'X scored %s points. O scored %s points.\' % (scores[\'X\'], scores[\'O\']))\n\n    if not playAgain():\n         sys.exit()\n",
    "AISim2":"# Reversi\n\nimport random\nimport sys\n\ndef drawBoard(board):\n    # This function prints out the board that it was passed. Returns None.\n    HLINE = \'  +---+---+---+---+---+---+---+---+\'\n    VLINE = \'  |   |   |   |   |   |   |   |   |\'\n\n    print(\'    1   2   3   4   5   6   7   8\')\n    print(HLINE)\n    for y in range(8):\n        print(VLINE)\n        print(y+1, end=\' \')\n        for x in range(8):\n            print(\'| %s\' % (board[x][y]), end=\' \')\n        print(\'|\')\n        print(VLINE)\n        print(HLINE)\n\n\ndef resetBoard(board):\n    # Blanks out the board it is passed, except for the original starting position.\n    for x in range(8):\n        for y in range(8):\n            board[x][y] = \' \'\n\n    # Starting pieces:\n    board[3][3] = \'X\'\n    board[3][4] = \'O\'\n    board[4][3] = \'O\'\n    board[4][4] = \'X\'\n\n\ndef getNewBoard():\n    # Creates a brand new, blank board data structure.\n    board = []\n    for i in range(8):\n        board.append([\' \'] * 8)\n\n    return board\n\n\ndef isValidMove(board, tile, xstart, ystart):\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\n        return False\n\n    board[xstart][ystart] = tile # temporarily set the tile on the board.\n\n    if tile == \'X\':\n        otherTile = \'O\'\n    else:\n        otherTile = \'X\'\n\n    tilesToFlip = []\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\n        x, y = xstart, ystart\n        x += xdirection # first step in the direction\n        y += ydirection # first step in the direction\n        if isOnBoard(x, y) and board[x][y] == otherTile:\n            # There is a piece belonging to the other player next to our piece.\n            x += xdirection\n            y += ydirection\n            if not isOnBoard(x, y):\n                continue\n            while board[x][y] == otherTile:\n                x += xdirection\n                y += ydirection\n                if not isOnBoard(x, y): # break out of while loop, then continue in for loop\n                    break\n            if not isOnBoard(x, y):\n                continue\n            if board[x][y] == tile:\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\n                while True:\n                    x -= xdirection\n                    y -= ydirection\n                    if x == xstart and y == ystart:\n                        break\n                    tilesToFlip.append([x, y])\n\n    board[xstart][ystart] = \' \' # restore the empty space\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\n        return False\n    return tilesToFlip\n\n\ndef isOnBoard(x, y):\n    # Returns True if the coordinates are located on the board.\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\n\n\ndef getBoardWithValidMoves(board, tile):\n    # Returns a new board with . marking the valid moves the given player can make.\n    dupeBoard = getBoardCopy(board)\n\n    for x, y in getValidMoves(dupeBoard, tile):\n        dupeBoard[x][y] = \'.\'\n    return dupeBoard\n\n\ndef getValidMoves(board, tile):\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\n    validMoves = []\n\n    for x in range(8):\n        for y in range(8):\n            if isValidMove(board, tile, x, y) != False:\n                validMoves.append([x, y])\n    return validMoves\n\n\ndef getScoreOfBoard(board):\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\n    xscore = 0\n    oscore = 0\n    for x in range(8):\n        for y in range(8):\n            if board[x][y] == \'X\':\n                xscore += 1\n            if board[x][y] == \'O\':\n                oscore += 1\n    return {\'X\':xscore, \'O\':oscore}\n\n\ndef enterPlayerTile():\n    # Let\'s the player type which tile they want to be.\n    # Returns a list with the player\'s tile as the first item, and the computer\'s tile as the second.\n    tile = \'\'\n    while not (tile == \'X\' or tile == \'O\'):\n        print(\'Do you want to be X or O?\')\n        tile = input().upper()\n\n    # the first element in the tuple is the player\'s tile, the second is the computer\'s tile.\n    if tile == \'X\':\n        return [\'X\', \'O\']\n    else:\n        return [\'O\', \'X\']\n\n\ndef whoGoesFirst():\n    # Randomly choose the player who goes first.\n    if random.randint(0, 1) == 0:\n        return \'computer\'\n    else:\n        return \'player\'\n\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\n\ndef makeMove(board, tile, xstart, ystart):\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\n    # Returns False if this is an invalid move, True if it is valid.\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\n\n    if tilesToFlip == False:\n        return False\n\n    board[xstart][ystart] = tile\n    for x, y in tilesToFlip:\n        board[x][y] = tile\n    return True\n\n\ndef getBoardCopy(board):\n    # Make a duplicate of the board list and return the duplicate.\n    dupeBoard = getNewBoard()\n\n    for x in range(8):\n        for y in range(8):\n            dupeBoard[x][y] = board[x][y]\n\n    return dupeBoard\n\n\ndef isOnCorner(x, y):\n    # Returns True if the position is in one of the four corners.\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\n\n\ndef getPlayerMove(board, playerTile):\n    # Let the player type in their move.\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\')\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\n    while True:\n        print(\'Enter your move, or type quit to end the game, or hints to turn off/on hints.\')\n        move = input().lower()\n        if move == \'quit\':\n            return \'quit\'\n        if move == \'hints\':\n            return \'hints\'\n\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\n            x = int(move[0]) - 1\n            y = int(move[1]) - 1\n            if isValidMove(board, playerTile, x, y) == False:\n                continue\n            else:\n                break\n        else:\n            print(\'That is not a valid move. Type the x digit (1-8), then the y digit (1-8).\')\n            print(\'For example, 81 will be the top-right corner.\')\n\n    return [x, y]\n\n\ndef getComputerMove(board, computerTile):\n    # Given a board and the computer\'s tile, determine where to\n    # move and return that move as a [x, y] list.\n    possibleMoves = getValidMoves(board, computerTile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    # Go through all the possible moves and remember the best scoring move\n    bestScore = -1\n    for x, y in possibleMoves:\n        dupeBoard = getBoardCopy(board)\n        makeMove(dupeBoard, computerTile, x, y)\n        score = getScoreOfBoard(dupeBoard)[computerTile]\n        if score > bestScore:\n            bestMove = [x, y]\n            bestScore = score\n    return bestMove\n\n\ndef showPoints(playerTile, computerTile):\n    # Prints out the current score.\n    scores = getScoreOfBoard(mainBoard)\n    print(\'You have %s points. The computer has %s points.\' % (scores[playerTile], scores[computerTile]))\n\n\n\nprint(\'Welcome to Reversi!\')\n\nxwins = 0\nowins = 0\nties = 0\nnumGames = int(input(\'Enter number of games to run: \'))\n\nfor game in range(numGames):\n    print(\'Game #%s:\' % (game), end=\' \')\n    # Reset the board and game.\n    mainBoard = getNewBoard()\n    resetBoard(mainBoard)\n    if whoGoesFirst() == \'player\':\n        turn = \'X\'\n    else:\n        turn = \'O\'\n\n    while True:\n        if turn == \'X\':\n            # X\'s turn.\n            otherTile = \'O\'\n            x, y = getComputerMove(mainBoard, \'X\')\n            makeMove(mainBoard, \'X\', x, y)\n        else:\n            # O\'s turn.\n            otherTile = \'X\'\n            x, y = getComputerMove(mainBoard, \'O\')\n            makeMove(mainBoard, \'O\', x, y)\n\n        if getValidMoves(mainBoard, otherTile) == []:\n            break\n        else:\n            turn = otherTile\n\n    # Display the final score.\n    scores = getScoreOfBoard(mainBoard)\n    print(\'X scored %s points. O scored %s points.\' % (scores[\'X\'], scores[\'O\']))\n\n    if scores[\'X\'] > scores[\'O\']:\n        xwins += 1\n    elif scores[\'X\'] < scores[\'O\']:\n        owins += 1\n    else:\n        ties += 1\n\nnumGames = float(numGames)\nxpercent = round(((xwins / numGames) * 100), 2)\nopercent = round(((owins / numGames) * 100), 2)\ntiepercent = round(((ties / numGames) * 100), 2)\nprint(\'X wins %s games (%s%%), O wins %s games (%s%%), ties for %s games (%s%%) of %s games total.\' % (xwins, xpercent, owins, opercent, ties, tiepercent, numGames))\n",
    "AISim3":"# Reversi\n\nimport random\nimport sys\n\ndef drawBoard(board):\n    # This function prints out the board that it was passed. Returns None.\n    HLINE = \'  +---+---+---+---+---+---+---+---+\'\n    VLINE = \'  |   |   |   |   |   |   |   |   |\'\n\n    print(\'    1   2   3   4   5   6   7   8\')\n    print(HLINE)\n    for y in range(8):\n        print(VLINE)\n        print(y+1, end=\' \')\n        for x in range(8):\n            print(\'| %s\' % (board[x][y]), end=\' \')\n        print(\'|\')\n        print(VLINE)\n        print(HLINE)\n\n\ndef resetBoard(board):\n    # Blanks out the board it is passed, except for the original starting position.\n    for x in range(8):\n        for y in range(8):\n            board[x][y] = \' \'\n\n    # Starting pieces:\n    board[3][3] = \'X\'\n    board[3][4] = \'O\'\n    board[4][3] = \'O\'\n    board[4][4] = \'X\'\n\n\ndef getNewBoard():\n    # Creates a brand new, blank board data structure.\n    board = []\n    for i in range(8):\n        board.append([\' \'] * 8)\n\n    return board\n\n\ndef isValidMove(board, tile, xstart, ystart):\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\n        return False\n\n    board[xstart][ystart] = tile # temporarily set the tile on the board.\n\n    if tile == \'X\':\n        otherTile = \'O\'\n    else:\n        otherTile = \'X\'\n\n    tilesToFlip = []\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\n        x, y = xstart, ystart\n        x += xdirection # first step in the direction\n        y += ydirection # first step in the direction\n        if isOnBoard(x, y) and board[x][y] == otherTile:\n            # There is a piece belonging to the other player next to our piece.\n            x += xdirection\n            y += ydirection\n            if not isOnBoard(x, y):\n                continue\n            while board[x][y] == otherTile:\n                x += xdirection\n                y += ydirection\n                if not isOnBoard(x, y): # break out of while loop, then continue in for loop\n                    break\n            if not isOnBoard(x, y):\n                continue\n            if board[x][y] == tile:\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\n                while True:\n                    x -= xdirection\n                    y -= ydirection\n                    if x == xstart and y == ystart:\n                        break\n                    tilesToFlip.append([x, y])\n\n    board[xstart][ystart] = \' \' # restore the empty space\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\n        return False\n    return tilesToFlip\n\n\ndef isOnBoard(x, y):\n    # Returns True if the coordinates are located on the board.\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\n\n\ndef getBoardWithValidMoves(board, tile):\n    # Returns a new board with . marking the valid moves the given player can make.\n    dupeBoard = getBoardCopy(board)\n\n    for x, y in getValidMoves(dupeBoard, tile):\n        dupeBoard[x][y] = \'.\'\n    return dupeBoard\n\n\ndef getValidMoves(board, tile):\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\n    validMoves = []\n\n    for x in range(8):\n        for y in range(8):\n            if isValidMove(board, tile, x, y) != False:\n                validMoves.append([x, y])\n    return validMoves\n\n\ndef getScoreOfBoard(board):\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\n    xscore = 0\n    oscore = 0\n    for x in range(8):\n        for y in range(8):\n            if board[x][y] == \'X\':\n                xscore += 1\n            if board[x][y] == \'O\':\n                oscore += 1\n    return {\'X\':xscore, \'O\':oscore}\n\n\ndef enterPlayerTile():\n    # Let\'s the player type which tile they want to be.\n    # Returns a list with the player\'s tile as the first item, and the computer\'s tile as the second.\n    tile = \'\'\n    while not (tile == \'X\' or tile == \'O\'):\n        print(\'Do you want to be X or O?\')\n        tile = input().upper()\n\n    # the first element in the tuple is the player\'s tile, the second is the computer\'s tile.\n    if tile == \'X\':\n        return [\'X\', \'O\']\n    else:\n        return [\'O\', \'X\']\n\n\ndef whoGoesFirst():\n    # Randomly choose the player who goes first.\n    if random.randint(0, 1) == 0:\n        return \'computer\'\n    else:\n        return \'player\'\n\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\n\ndef makeMove(board, tile, xstart, ystart):\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\n    # Returns False if this is an invalid move, True if it is valid.\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\n\n    if tilesToFlip == False:\n        return False\n\n    board[xstart][ystart] = tile\n    for x, y in tilesToFlip:\n        board[x][y] = tile\n    return True\n\n\ndef getBoardCopy(board):\n    # Make a duplicate of the board list and return the duplicate.\n    dupeBoard = getNewBoard()\n\n    for x in range(8):\n        for y in range(8):\n            dupeBoard[x][y] = board[x][y]\n\n    return dupeBoard\n\n\ndef isOnCorner(x, y):\n    # Returns True if the position is in one of the four corners.\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\n\n\ndef getPlayerMove(board, playerTile):\n    # Let the player type in their move.\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\')\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\n    while True:\n        print(\'Enter your move, or type quit to end the game, or hints to turn off/on hints.\')\n        move = input().lower()\n        if move == \'quit\':\n            return \'quit\'\n        if move == \'hints\':\n            return \'hints\'\n\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\n            x = int(move[0]) - 1\n            y = int(move[1]) - 1\n            if isValidMove(board, playerTile, x, y) == False:\n                continue\n            else:\n                break\n        else:\n            print(\'That is not a valid move. Type the x digit (1-8), then the y digit (1-8).\')\n            print(\'For example, 81 will be the top-right corner.\')\n\n    return [x, y]\n\n\ndef getComputerMove(board, computerTile):\n    # Given a board and the computer\'s tile, determine where to\n    # move and return that move as a [x, y] list.\n    possibleMoves = getValidMoves(board, computerTile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    # Go through all the possible moves and remember the best scoring move\n    bestScore = -1\n    for x, y in possibleMoves:\n        dupeBoard = getBoardCopy(board)\n        makeMove(dupeBoard, computerTile, x, y)\n        score = getScoreOfBoard(dupeBoard)[computerTile]\n        if score > bestScore:\n            bestMove = [x, y]\n            bestScore = score\n    return bestMove\n\n\ndef showPoints(playerTile, computerTile):\n    # Prints out the current score.\n    scores = getScoreOfBoard(mainBoard)\n    print(\'You have %s points. The computer has %s points.\' % (scores[playerTile], scores[computerTile]))\n\n\ndef getRandomMove(board, tile):\n    # Return a random move.\n    return random.choice( getValidMoves(board, tile) )\n\n\ndef isOnSide(x, y):\n    return x == 0 or x == 7 or y == 0 or y ==7\n\n\ndef getCornerSideBestMove(board, tile):\n    # Return a corner move, or a side move, or the best move.\n    possibleMoves = getValidMoves(board, tile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    # if there is no corner, return a side move.\n    for x, y in possibleMoves:\n        if isOnSide(x, y):\n            return [x, y]\n\n    return getComputerMove(board, tile)\n\n\ndef getSideBestMove(board, tile):\n    # Return a corner move, or a side move, or the best move.\n    possibleMoves = getValidMoves(board, tile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # return a side move, if available\n    for x, y in possibleMoves:\n        if isOnSide(x, y):\n            return [x, y]\n\n    return getComputerMove(board, tile)\n\n\ndef getWorstMove(board, tile):\n    # Return the move that flips the least number of tiles.\n    possibleMoves = getValidMoves(board, tile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # Go through all the possible moves and remember the best scoring move\n    worstScore = 64\n    for x, y in possibleMoves:\n        dupeBoard = getBoardCopy(board)\n        makeMove(dupeBoard, tile, x, y)\n        score = getScoreOfBoard(dupeBoard)[tile]\n        if score < worstScore:\n            worstMove = [x, y]\n            worstScore = score\n\n    return worstMove\n\n\ndef getCornerWorstMove(board, tile):\n    # Return a corner, a space, or the move that flips the least number of tiles.\n    possibleMoves = getValidMoves(board, tile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    return getWorstMove(board, tile)\n\n\n\nprint(\'Welcome to Reversi!\')\n\n\nxwins = 0\nowins = 0\nties = 0\nnumGames = int(input(\'Enter number of games to run: \'))\n\nfor game in range(numGames):\n    print(\'Game #%s:\' % (game), end=\' \')\n    # Reset the board and game.\n    mainBoard = getNewBoard()\n    resetBoard(mainBoard)\n    if whoGoesFirst() == \'player\':\n        turn = \'X\'\n    else:\n        turn = \'O\'\n\n    while True:\n        if turn == \'X\':\n            # X\'s turn.\n            otherTile = \'O\'\n            x, y = getComputerMove(mainBoard, \'X\')\n            makeMove(mainBoard, \'X\', x, y)\n        else:\n            # O\'s turn.\n            otherTile = \'X\'\n            x, y = getComputerMove(mainBoard, \'O\')\n            makeMove(mainBoard, \'O\', x, y)\n\n        if getValidMoves(mainBoard, otherTile) == []:\n            break\n        else:\n            turn = otherTile\n\n    # Display the final score.\n    scores = getScoreOfBoard(mainBoard)\n    print(\'X scored %s points. O scored %s points.\' % (scores[\'X\'], scores[\'O\']))\n\n    if scores[\'X\'] > scores[\'O\']:\n        xwins += 1\n    elif scores[\'X\'] < scores[\'O\']:\n        owins += 1\n    else:\n        ties += 1\n\nnumGames = float(numGames)\nxpercent = round(((xwins / numGames) * 100), 2)\nopercent = round(((owins / numGames) * 100), 2)\ntiepercent = round(((ties / numGames) * 100), 2)\nprint(\'X wins %s games (%s%%), O wins %s games (%s%%), ties for %s games (%s%%) of %s games total.\' % (xwins, xpercent, owins, opercent, ties, tiepercent, numGames))\n",
    "animation":"import pygame, sys, time\nfrom pygame.locals import *\n\n# set up pygame\npygame.init()\n\n# set up the window\nWINDOWWIDTH = 400\nWINDOWHEIGHT = 400\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\npygame.display.set_caption(\'Animation\')\n\n# set up direction variables\nDOWNLEFT = 1\nDOWNRIGHT = 3\nUPLEFT = 7\nUPRIGHT = 9\n\nMOVESPEED = 4\n\n# set up the colors\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\n\n# set up the block data structure\nb1 = {\'rect\':pygame.Rect(300, 80, 50, 100), \'color\':RED, \'dir\':UPRIGHT}\nb2 = {\'rect\':pygame.Rect(200, 200, 20, 20), \'color\':GREEN, \'dir\':UPLEFT}\nb3 = {\'rect\':pygame.Rect(100, 150, 60, 60), \'color\':BLUE, \'dir\':DOWNLEFT}\nblocks = [b1, b2, b3]\n\n# run the game loop\nwhile True:\n    # check for the QUIT event\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n\n    # draw the black background onto the surface\n    windowSurface.fill(BLACK)\n\n    for b in blocks:\n        # move the block data structure\n        if b[\'dir\'] == DOWNLEFT:\n            b[\'rect\'].left -= MOVESPEED\n            b[\'rect\'].top += MOVESPEED\n        if b[\'dir\'] == DOWNRIGHT:\n            b[\'rect\'].left += MOVESPEED\n            b[\'rect\'].top += MOVESPEED\n        if b[\'dir\'] == UPLEFT:\n            b[\'rect\'].left -= MOVESPEED\n            b[\'rect\'].top -= MOVESPEED\n        if b[\'dir\'] == UPRIGHT:\n            b[\'rect\'].left += MOVESPEED\n            b[\'rect\'].top -= MOVESPEED\n\n        # check if the block has move out of the window\n        if b[\'rect\'].top < 0:\n            # block has moved past the top\n            if b[\'dir\'] == UPLEFT:\n                b[\'dir\'] = DOWNLEFT\n            if b[\'dir\'] == UPRIGHT:\n                b[\'dir\'] = DOWNRIGHT\n        if b[\'rect\'].bottom > WINDOWHEIGHT:\n            # block has moved past the bottom\n            if b[\'dir\'] == DOWNLEFT:\n                b[\'dir\'] = UPLEFT\n            if b[\'dir\'] == DOWNRIGHT:\n                b[\'dir\'] = UPRIGHT\n        if b[\'rect\'].left < 0:\n            # block has moved past the left side\n            if b[\'dir\'] == DOWNLEFT:\n                b[\'dir\'] = DOWNRIGHT\n            if b[\'dir\'] == UPLEFT:\n                b[\'dir\'] = UPRIGHT\n        if b[\'rect\'].right > WINDOWWIDTH:\n            # block has moved past the right side\n            if b[\'dir\'] == DOWNRIGHT:\n                b[\'dir\'] = DOWNLEFT\n            if b[\'dir\'] == UPRIGHT:\n                b[\'dir\'] = UPLEFT\n\n        # draw the block onto the surface\n        pygame.draw.rect(windowSurface, b[\'color\'], b[\'rect\'])\n\n    # draw the window onto the screen\n    pygame.display.update()\n    time.sleep(0.02)\n",
    "bagels":"import random\ndef getSecretNum(numDigits):\n    # Returns a string that is numDigits long, made up of unique random digits.\n    numbers = list(range(10))\n    random.shuffle(numbers)\n    secretNum = \'\'\n    for i in range(numDigits):\n        secretNum += str(numbers[i])\n    return secretNum\n\ndef getClues(guess, secretNum):\n    # Returns a string with the pico, fermi, bagels clues to the user.\n    if guess == secretNum:\n        return \'You got it!\'\n\n    clue = []\n\n    for i in range(len(guess)):\n        if guess[i] == secretNum[i]:\n            clue.append(\'Fermi\')\n        elif guess[i] in secretNum:\n            clue.append(\'Pico\')\n    if len(clue) == 0:\n        return \'Bagels\'\n\n    clue.sort()\n    return \' \'.join(clue)\n\ndef isOnlyDigits(num):\n    # Returns True if num is a string made up only of digits. Otherwise returns False.\n    if num == \'\':\n        return False\n\n    for i in num:\n        if i not in \'0 1 2 3 4 5 6 7 8 9\'.split():\n            return False\n\n    return True\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\nNUMDIGITS = 3\nMAXGUESS = 10\n\nprint(\'I am thinking of a %s-digit number. Try to guess what it is.\' % (NUMDIGITS))\nprint(\'Here are some clues:\')\nprint(\'When I say:    That means:\')\nprint(\'  Pico         One digit is correct but in the wrong position.\')\nprint(\'  Fermi        One digit is correct and in the right position.\')\nprint(\'  Bagels       No digit is correct.\')\n\nwhile True:\n    secretNum = getSecretNum(NUMDIGITS)\n    print(\'I have thought up a number. You have %s guesses to get it.\' % (MAXGUESS))\n\n    numGuesses = 1\n    while numGuesses <= MAXGUESS:\n        guess = \'\'\n        while len(guess) != NUMDIGITS or not isOnlyDigits(guess):\n            print(\'Guess #%s: \' % (numGuesses))\n            guess = input()\n\n        clue = getClues(guess, secretNum)\n        print(clue)\n        numGuesses += 1\n\n        if guess == secretNum:\n            break\n        if numGuesses > MAXGUESS:\n            print(\'You ran out of guesses. The answer was %s.\' % (secretNum))\n\n    if not playAgain():\n        break\n",
    "cipher":"# Caesar Cipher\n\nMAX_KEY_SIZE = 26\n\ndef getMode():\n    while True:\n        print(\'Do you wish to encrypt or decrypt a message?\')\n        mode = input().lower()\n        if mode in \'encrypt e decrypt d\'.split():\n            return mode\n        else:\n            print(\'Enter either \"encrypt\" or \"e\" or \"decrypt\" or \"d\".\')\n\ndef getMessage():\n    print(\'Enter your message:\')\n    return input()\n\ndef getKey():\n    key = 0\n    while True:\n        print(\'Enter the key number (1-%s)\' % (MAX_KEY_SIZE))\n        key = int(input())\n        if (key >= 1 and key <= MAX_KEY_SIZE):\n            return key\n\ndef getTranslatedMessage(mode, message, key):\n    if mode[0] == \'d\':\n        key = -key\n    translated = \'\'\n\n    for symbol in message:\n        if symbol.isalpha():\n            num = ord(symbol)\n            num += key\n\n            if symbol.isupper():\n                if num > ord(\'Z\'):\n                    num -= 26\n                elif num < ord(\'A\'):\n                    num += 26\n            elif symbol.islower():\n                if num > ord(\'z\'):\n                    num -= 26\n                elif num < ord(\'a\'):\n                    num += 26\n\n            translated += chr(num)\n        else:\n            translated += symbol\n    return translated\n\nmode = getMode()\nmessage = getMessage()\nkey = getKey()\n\nprint(\'Your translated text is:\')\nprint(getTranslatedMessage(mode, message, key))\n",
    "collisionDetection":"import pygame, sys, random\nfrom pygame.locals import *\n\ndef doRectsOverlap(rect1, rect2):\n    for a, b in [(rect1, rect2), (rect2, rect1)]:\n        # Check if a\'s corners are inside b\n        if ((isPointInsideRect(a.left, a.top, b)) or\n            (isPointInsideRect(a.left, a.bottom, b)) or\n            (isPointInsideRect(a.right, a.top, b)) or\n            (isPointInsideRect(a.right, a.bottom, b))):\n            return True\n\n    return False\n\ndef isPointInsideRect(x, y, rect):\n    if (x > rect.left) and (x < rect.right) and (y > rect.top) and (y < rect.bottom):\n        return True\n    else:\n        return False\n\n\n# set up pygame\npygame.init()\nmainClock = pygame.time.Clock()\n\n# set up the window\nWINDOWWIDTH = 400\nWINDOWHEIGHT = 400\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\npygame.display.set_caption(\'Collision Detection\')\n\n# set up direction variables\nDOWNLEFT = 1\nDOWNRIGHT = 3\nUPLEFT = 7\nUPRIGHT = 9\n\nMOVESPEED = 4\n\n# set up the colors\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nWHITE = (255, 255, 255)\n\n# set up the bouncer and food data structures\nfoodCounter = 0\nNEWFOOD = 40\nFOODSIZE = 20\nbouncer = {\'rect\':pygame.Rect(300, 100, 50, 50), \'dir\':UPLEFT}\nfoods = []\nfor i in range(20):\n    foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - FOODSIZE), random.randint(0, WINDOWHEIGHT - FOODSIZE), FOODSIZE, FOODSIZE))\n\n# run the game loop\nwhile True:\n    # check for the QUIT event\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n\n    foodCounter += 1\n    if foodCounter >= NEWFOOD:\n        # add new food\n        foodCounter = 0\n        foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - FOODSIZE), random.randint(0, WINDOWHEIGHT - FOODSIZE), FOODSIZE, FOODSIZE))\n\n    # draw the black background onto the surface\n    windowSurface.fill(BLACK)\n\n    # move the bouncer data structure\n    if bouncer[\'dir\'] == DOWNLEFT:\n        bouncer[\'rect\'].left -= MOVESPEED\n        bouncer[\'rect\'].top += MOVESPEED\n    if bouncer[\'dir\'] == DOWNRIGHT:\n        bouncer[\'rect\'].left += MOVESPEED\n        bouncer[\'rect\'].top += MOVESPEED\n    if bouncer[\'dir\'] == UPLEFT:\n        bouncer[\'rect\'].left -= MOVESPEED\n        bouncer[\'rect\'].top -= MOVESPEED\n    if bouncer[\'dir\'] == UPRIGHT:\n        bouncer[\'rect\'].left += MOVESPEED\n        bouncer[\'rect\'].top -= MOVESPEED\n\n    # check if the bouncer has move out of the window\n    if bouncer[\'rect\'].top < 0:\n        # bouncer has moved past the top\n        if bouncer[\'dir\'] == UPLEFT:\n            bouncer[\'dir\'] = DOWNLEFT\n        if bouncer[\'dir\'] == UPRIGHT:\n            bouncer[\'dir\'] = DOWNRIGHT\n    if bouncer[\'rect\'].bottom > WINDOWHEIGHT:\n        # bouncer has moved past the bottom\n        if bouncer[\'dir\'] == DOWNLEFT:\n            bouncer[\'dir\'] = UPLEFT\n        if bouncer[\'dir\'] == DOWNRIGHT:\n            bouncer[\'dir\'] = UPRIGHT\n    if bouncer[\'rect\'].left < 0:\n        # bouncer has moved past the left side\n        if bouncer[\'dir\'] == DOWNLEFT:\n            bouncer[\'dir\'] = DOWNRIGHT\n        if bouncer[\'dir\'] == UPLEFT:\n            bouncer[\'dir\'] = UPRIGHT\n    if bouncer[\'rect\'].right > WINDOWWIDTH:\n        # bouncer has moved past the right side\n        if bouncer[\'dir\'] == DOWNRIGHT:\n            bouncer[\'dir\'] = DOWNLEFT\n        if bouncer[\'dir\'] == UPRIGHT:\n            bouncer[\'dir\'] = UPLEFT\n\n    # draw the bouncer onto the surface\n    pygame.draw.rect(windowSurface, WHITE, bouncer[\'rect\'])\n\n    # check if the bouncer has intersected with any food squares.\n    for food in foods[:]:\n        if doRectsOverlap(bouncer[\'rect\'], food):\n            foods.remove(food)\n\n    # draw the food\n    for i in range(len(foods)):\n        pygame.draw.rect(windowSurface, GREEN, foods[i])\n\n    # draw the window onto the screen\n    pygame.display.update()\n    mainClock.tick(40)\n",
    "dodger":"import pygame, random, sys\nfrom pygame.locals import *\n\nWINDOWWIDTH = 600\nWINDOWHEIGHT = 600\nTEXTCOLOR = (255, 255, 255)\nBACKGROUNDCOLOR = (0, 0, 0)\nFPS = 40\nBADDIEMINSIZE = 10\nBADDIEMAXSIZE = 40\nBADDIEMINSPEED = 1\nBADDIEMAXSPEED = 8\nADDNEWBADDIERATE = 6\nPLAYERMOVERATE = 5\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\ndef waitForPlayerToPressKey():\n    while True:\n        for event in pygame.event.get():\n            if event.type == QUIT:\n                terminate()\n            if event.type == KEYDOWN:\n                if event.key == K_ESCAPE: # pressing escape quits\n                    terminate()\n                return\n\ndef playerHasHitBaddie(playerRect, baddies):\n    for b in baddies:\n        if playerRect.colliderect(b[\'rect\']):\n            return True\n    return False\n\ndef drawText(text, font, surface, x, y):\n    textobj = font.render(text, 1, TEXTCOLOR)\n    textrect = textobj.get_rect()\n    textrect.topleft = (x, y)\n    surface.blit(textobj, textrect)\n\n# set up pygame, the window, and the mouse cursor\npygame.init()\nmainClock = pygame.time.Clock()\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\npygame.display.set_caption(\'Dodger\')\npygame.mouse.set_visible(False)\n\n# set up fonts\nfont = pygame.font.SysFont(None, 48)\n\n# set up sounds\ngameOverSound = pygame.mixer.Sound(\'gameover.wav\')\npygame.mixer.music.load(\'background.mid\')\n\n# set up images\nplayerImage = pygame.image.load(\'player.png\')\nplayerRect = playerImage.get_rect()\nbaddieImage = pygame.image.load(\'baddie.png\')\n\n# show the \"Start\" screen\ndrawText(\'Dodger\', font, windowSurface, (WINDOWWIDTH / 3), (WINDOWHEIGHT / 3))\ndrawText(\'Press a key to start.\', font, windowSurface, (WINDOWWIDTH / 3) - 30, (WINDOWHEIGHT / 3) + 50)\npygame.display.update()\nwaitForPlayerToPressKey()\n\n\ntopScore = 0\nwhile True:\n    # set up the start of the game\n    baddies = []\n    score = 0\n    playerRect.topleft = (WINDOWWIDTH / 2, WINDOWHEIGHT - 50)\n    moveLeft = moveRight = moveUp = moveDown = False\n    reverseCheat = slowCheat = False\n    baddieAddCounter = 0\n    pygame.mixer.music.play(-1, 0.0)\n\n    while True: # the game loop runs while the game part is playing\n        score += 1 # increase score\n\n        for event in pygame.event.get():\n            if event.type == QUIT:\n                terminate()\n\n            if event.type == KEYDOWN:\n                if event.key == ord(\'z\'):\n                    reverseCheat = True\n                if event.key == ord(\'x\'):\n                    slowCheat = True\n                if event.key == K_LEFT or event.key == ord(\'a\'):\n                    moveRight = False\n                    moveLeft = True\n                if event.key == K_RIGHT or event.key == ord(\'d\'):\n                    moveLeft = False\n                    moveRight = True\n                if event.key == K_UP or event.key == ord(\'w\'):\n                    moveDown = False\n                    moveUp = True\n                if event.key == K_DOWN or event.key == ord(\'s\'):\n                    moveUp = False\n                    moveDown = True\n\n            if event.type == KEYUP:\n                if event.key == ord(\'z\'):\n                    reverseCheat = False\n                    score = 0\n                if event.key == ord(\'x\'):\n                    slowCheat = False\n                    score = 0\n                if event.key == K_ESCAPE:\n                        terminate()\n\n                if event.key == K_LEFT or event.key == ord(\'a\'):\n                    moveLeft = False\n                if event.key == K_RIGHT or event.key == ord(\'d\'):\n                    moveRight = False\n                if event.key == K_UP or event.key == ord(\'w\'):\n                    moveUp = False\n                if event.key == K_DOWN or event.key == ord(\'s\'):\n                    moveDown = False\n\n            if event.type == MOUSEMOTION:\n                # If the mouse moves, move the player where the cursor is.\n                playerRect.move_ip(event.pos[0] - playerRect.centerx, event.pos[1] - playerRect.centery)\n\n        # Add new baddies at the top of the screen, if needed.\n        if not reverseCheat and not slowCheat:\n            baddieAddCounter += 1\n        if baddieAddCounter == ADDNEWBADDIERATE:\n            baddieAddCounter = 0\n            baddieSize = random.randint(BADDIEMINSIZE, BADDIEMAXSIZE)\n            newBaddie = {\'rect\': pygame.Rect(random.randint(0, WINDOWWIDTH-baddieSize), 0 - baddieSize, baddieSize, baddieSize),\n                        \'speed\': random.randint(BADDIEMINSPEED, BADDIEMAXSPEED),\n                        \'surface\':pygame.transform.scale(baddieImage, (baddieSize, baddieSize)),\n                        }\n\n            baddies.append(newBaddie)\n\n        # Move the player around.\n        if moveLeft and playerRect.left > 0:\n            playerRect.move_ip(-1 * PLAYERMOVERATE, 0)\n        if moveRight and playerRect.right < WINDOWWIDTH:\n            playerRect.move_ip(PLAYERMOVERATE, 0)\n        if moveUp and playerRect.top > 0:\n            playerRect.move_ip(0, -1 * PLAYERMOVERATE)\n        if moveDown and playerRect.bottom < WINDOWHEIGHT:\n            playerRect.move_ip(0, PLAYERMOVERATE)\n\n        # Move the mouse cursor to match the player.\n        pygame.mouse.set_pos(playerRect.centerx, playerRect.centery)\n\n        # Move the baddies down.\n        for b in baddies:\n            if not reverseCheat and not slowCheat:\n                b[\'rect\'].move_ip(0, b[\'speed\'])\n            elif reverseCheat:\n                b[\'rect\'].move_ip(0, -5)\n            elif slowCheat:\n                b[\'rect\'].move_ip(0, 1)\n\n         # Delete baddies that have fallen past the bottom.\n        for b in baddies[:]:\n            if b[\'rect\'].top > WINDOWHEIGHT:\n                baddies.remove(b)\n\n        # Draw the game world on the window.\n        windowSurface.fill(BACKGROUNDCOLOR)\n\n        # Draw the score and top score.\n        drawText(\'Score: %s\' % (score), font, windowSurface, 10, 0)\n        drawText(\'Top Score: %s\' % (topScore), font, windowSurface, 10, 40)\n\n        # Draw the player\'s rectangle\n        windowSurface.blit(playerImage, playerRect)\n\n        # Draw each baddie\n        for b in baddies:\n            windowSurface.blit(b[\'surface\'], b[\'rect\'])\n\n        pygame.display.update()\n\n        # Check if any of the baddies have hit the player.\n        if playerHasHitBaddie(playerRect, baddies):\n            if score > topScore:\n                topScore = score # set new top score\n            break\n\n        mainClock.tick(FPS)\n\n    # Stop the game and show the \"Game Over\" screen.\n    pygame.mixer.music.stop()\n    gameOverSound.play()\n\n    drawText(\'GAME OVER\', font, windowSurface, (WINDOWWIDTH / 3), (WINDOWHEIGHT / 3))\n    drawText(\'Press a key to play again.\', font, windowSurface, (WINDOWWIDTH / 3) - 80, (WINDOWHEIGHT / 3) + 50)\n    pygame.display.update()\n    waitForPlayerToPressKey()\n\n    gameOverSound.stop()\n",
    "dragon":"import random\nimport time\n\ndef displayIntro():\n    print(\'You are in a land full of dragons. In front of you,\')\n    print(\'you see two caves. In one cave, the dragon is friendly\')\n    print(\'and will share his treasure with you. The other dragon\')\n    print(\'is greedy and hungry, and will eat you on sight.\')\n    print()\n\ndef chooseCave():\n    cave = \'\'\n    while cave != \'1\' and cave != \'2\':\n        print(\'Which cave will you go into? (1 or 2)\')\n        cave = input()\n\n    return cave\n\ndef checkCave(chosenCave):\n    print(\'You approach the cave...\')\n    time.sleep(2)\n    print(\'It is dark and spooky...\')\n    time.sleep(2)\n    print(\'A large dragon jumps out in front of you! He opens his jaws and...\')\n    print()\n    time.sleep(2)\n\n    friendlyCave = random.randint(1, 2)\n\n    if chosenCave == str(friendlyCave):\n         print(\'Gives you his treasure!\')\n    else:\n         print(\'Gobbles you down in one bite!\')\n\nplayAgain = \'yes\'\nwhile playAgain == \'yes\' or playAgain == \'y\':\n\n    displayIntro()\n\n    caveNumber = chooseCave()\n\n    checkCave(caveNumber)\n\n    print(\'Do you want to play again? (yes or no)\')\n    playAgain = input()\n",
    "guess":"# This is a guess the number game.\nimport random\n\nguessesTaken = 0\n\nprint(\'Hello! What is your name?\')\nmyName = input()\n\nnumber = random.randint(1, 20)\nprint(\'Well, \' + myName + \', I am thinking of a number between 1 and 20.\')\n\nwhile guessesTaken < 6:\n    print(\'Take a guess.\') # There are four spaces in front of print.\n    guess = input()\n    guess = int(guess)\n\n    guessesTaken = guessesTaken + 1\n\n    if guess < number:\n        print(\'Your guess is too low.\') # There are eight spaces in front of print.\n\n    if guess > number:\n        print(\'Your guess is too high.\')\n\n    if guess == number:\n        break\n\nif guess == number:\n    guessesTaken = str(guessesTaken)\n    print(\'Good job, \' + myName + \'! You guessed my number in \' + guessesTaken + \' guesses!\')\n\nif guess != number:\n    number = str(number)\n    print(\'Nope. The number I was thinking of was \' + number)\n",
    "hangman":"import random\nHANGMANPICS = [\'\'\'\n\n  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========\'\'\', \'\'\'\n\n  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========\'\'\', \'\'\'\n\n  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========\'\'\', \'\'\'\n\n  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========\'\'\', \'\'\'\n\n  +---+\n  |   |\n  O   |\n /|\\  |\n      |\n      |\n=========\'\'\', \'\'\'\n\n  +---+\n  |   |\n  O   |\n /|\\  |\n /    |\n      |\n=========\'\'\', \'\'\'\n\n  +---+\n  |   |\n  O   |\n /|\\  |\n / \\  |\n      |\n=========\'\'\']\nwords = \'ant baboon badger bat bear beaver camel cat clam cobra cougar coyote crow deer dog donkey duck eagle ferret fox frog goat goose hawk lion lizard llama mole monkey moose mouse mule newt otter owl panda parrot pigeon python rabbit ram rat raven rhino salmon seal shark sheep skunk sloth snake spider stork swan tiger toad trout turkey turtle weasel whale wolf wombat zebra\'.split()\n\ndef getRandomWord(wordList):\n    # This function returns a random string from the passed list of strings.\n    wordIndex = random.randint(0, len(wordList) - 1)\n    return wordList[wordIndex]\n\ndef displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord):\n    print(HANGMANPICS[len(missedLetters)])\n    print()\n\n    print(\'Missed letters:\', end=\' \')\n    for letter in missedLetters:\n        print(letter, end=\' \')\n    print()\n\n    blanks = \'_\' * len(secretWord)\n\n    for i in range(len(secretWord)): # replace blanks with correctly guessed letters\n        if secretWord[i] in correctLetters:\n            blanks = blanks[:i] + secretWord[i] + blanks[i+1:]\n\n    for letter in blanks: # show the secret word with spaces in between each letter\n        print(letter, end=\' \')\n    print()\n\ndef getGuess(alreadyGuessed):\n    # Returns the letter the player entered. This function makes sure the player entered a single letter, and not something else.\n    while True:\n        print(\'Guess a letter.\')\n        guess = input()\n        guess = guess.lower()\n        if len(guess) != 1:\n            print(\'Please enter a single letter.\')\n        elif guess in alreadyGuessed:\n            print(\'You have already guessed that letter. Choose again.\')\n        elif guess not in \'abcdefghijklmnopqrstuvwxyz\':\n            print(\'Please enter a LETTER.\')\n        else:\n            return guess\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\n\nprint(\'H A N G M A N\')\nmissedLetters = \'\'\ncorrectLetters = \'\'\nsecretWord = getRandomWord(words)\ngameIsDone = False\n\nwhile True:\n    displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord)\n\n    # Let the player type in a letter.\n    guess = getGuess(missedLetters + correctLetters)\n\n    if guess in secretWord:\n        correctLetters = correctLetters + guess\n\n        # Check if the player has won\n        foundAllLetters = True\n        for i in range(len(secretWord)):\n            if secretWord[i] not in correctLetters:\n                foundAllLetters = False\n                break\n        if foundAllLetters:\n            print(\'Yes! The secret word is \"\' + secretWord + \'\"! You have won!\')\n            gameIsDone = True\n    else:\n        missedLetters = missedLetters + guess\n\n        # Check if player has guessed too many times and lost\n        if len(missedLetters) == len(HANGMANPICS) - 1:\n            displayBoard(HANGMANPICS, missedLetters, correctLetters, secretWord)\n            print(\'You have run out of guesses!\\nAfter \' + str(len(missedLetters)) + \' missed guesses and \' + str(len(correctLetters)) + \' correct guesses, the word was \"\' + secretWord + \'\"\')\n            gameIsDone = True\n\n    # Ask the player if they want to play again (but only if the game is done).\n    if gameIsDone:\n        if playAgain():\n            missedLetters = \'\'\n            correctLetters = \'\'\n            gameIsDone = False\n            secretWord = getRandomWord(words)\n        else:\n            break\n",
    "hello":"# This program says hello and asks for my name.\nprint(\'Hello world!\')\nprint(\'What is your name?\')\nmyName = input()\nprint(\'It is good to meet you, \' + myName)\n",
    "jokes":"print(\'What do you get when you cross a snowman with a vampire?\')\ninput()\nprint(\'Frostbite!\')\nprint()\nprint(\'What do dentists call a astronaut\\\'s cavity?\')\ninput()\nprint(\'A black hole!\')\nprint()\nprint(\'Knock knock.\')\ninput()\nprint(\"Who\'s there?\")\ninput()\nprint(\'Interrupting cow.\')\ninput()\nprint(\'Interrupting cow wh\', end=\'\')\nprint(\'-MOO!\')\n",
    "pygameHelloWorld":"import pygame, sys\nfrom pygame.locals import *\n\n# set up pygame\npygame.init()\n\n# set up the window\nwindowSurface = pygame.display.set_mode((500, 400), 0, 32)\npygame.display.set_caption(\'Hello world!\')\n\n# set up the colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\n\n# set up fonts\nbasicFont = pygame.font.SysFont(None, 48)\n\n# set up the text\ntext = basicFont.render(\'Hello world!\', True, WHITE, BLUE)\ntextRect = text.get_rect()\ntextRect.centerx = windowSurface.get_rect().centerx\ntextRect.centery = windowSurface.get_rect().centery\n\n# draw the white background onto the surface\nwindowSurface.fill(WHITE)\n\n# draw a green polygon onto the surface\npygame.draw.polygon(windowSurface, GREEN, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))\n\n# draw some blue lines onto the surface\npygame.draw.line(windowSurface, BLUE, (60, 60), (120, 60), 4)\npygame.draw.line(windowSurface, BLUE, (120, 60), (60, 120))\npygame.draw.line(windowSurface, BLUE, (60, 120), (120, 120), 4)\n\n# draw a blue circle onto the surface\npygame.draw.circle(windowSurface, BLUE, (300, 50), 20, 0)\n\n# draw a red ellipse onto the surface\npygame.draw.ellipse(windowSurface, RED, (300, 250, 40, 80), 1)\n\n# draw the text\'s background rectangle onto the surface\npygame.draw.rect(windowSurface, RED, (textRect.left - 20, textRect.top - 20, textRect.width + 40, textRect.height + 40))\n\n# get a pixel array of the surface\npixArray = pygame.PixelArray(windowSurface)\npixArray[480][380] = BLACK\ndel pixArray\n\n# draw the text onto the surface\nwindowSurface.blit(text, textRect)\n\n# draw the window onto the screen\npygame.display.update()\n\n# run the game loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n",
    "pygameInput":"import pygame, sys, random\nfrom pygame.locals import *\n\n# set up pygame\npygame.init()\nmainClock = pygame.time.Clock()\n\n# set up the window\nWINDOWWIDTH = 400\nWINDOWHEIGHT = 400\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\npygame.display.set_caption(\'Input\')\n\n# set up the colors\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nWHITE = (255, 255, 255)\n\n# set up the player and food data structure\nfoodCounter = 0\nNEWFOOD = 40\nFOODSIZE = 20\nplayer = pygame.Rect(300, 100, 50, 50)\nfoods = []\nfor i in range(20):\n    foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - FOODSIZE), random.randint(0, WINDOWHEIGHT - FOODSIZE), FOODSIZE, FOODSIZE))\n\n# set up movement variables\nmoveLeft = False\nmoveRight = False\nmoveUp = False\nmoveDown = False\n\nMOVESPEED = 6\n\n\n# run the game loop\nwhile True:\n    # check for events\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == KEYDOWN:\n            # change the keyboard variables\n            if event.key == K_LEFT or event.key == ord(\'a\'):\n                moveRight = False\n                moveLeft = True\n            if event.key == K_RIGHT or event.key == ord(\'d\'):\n                moveLeft = False\n                moveRight = True\n            if event.key == K_UP or event.key == ord(\'w\'):\n                moveDown = False\n                moveUp = True\n            if event.key == K_DOWN or event.key == ord(\'s\'):\n                moveUp = False\n                moveDown = True\n        if event.type == KEYUP:\n            if event.key == K_ESCAPE:\n                pygame.quit()\n                sys.exit()\n            if event.key == K_LEFT or event.key == ord(\'a\'):\n                moveLeft = False\n            if event.key == K_RIGHT or event.key == ord(\'d\'):\n                moveRight = False\n            if event.key == K_UP or event.key == ord(\'w\'):\n                moveUp = False\n            if event.key == K_DOWN or event.key == ord(\'s\'):\n                moveDown = False\n            if event.key == ord(\'x\'):\n                player.top = random.randint(0, WINDOWHEIGHT - player.height)\n                player.left = random.randint(0, WINDOWWIDTH - player.width)\n\n        if event.type == MOUSEBUTTONUP:\n            foods.append(pygame.Rect(event.pos[0], event.pos[1], FOODSIZE, FOODSIZE))\n\n    foodCounter += 1\n    if foodCounter >= NEWFOOD:\n        # add new food\n        foodCounter = 0\n        foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - FOODSIZE), random.randint(0, WINDOWHEIGHT - FOODSIZE), FOODSIZE, FOODSIZE))\n\n    # draw the black background onto the surface\n    windowSurface.fill(BLACK)\n\n    # move the player\n    if moveDown and player.bottom < WINDOWHEIGHT:\n        player.top += MOVESPEED\n    if moveUp and player.top > 0:\n        player.top -= MOVESPEED\n    if moveLeft and player.left > 0:\n        player.left -= MOVESPEED\n    if moveRight and player.right < WINDOWWIDTH:\n        player.right += MOVESPEED\n\n    # draw the player onto the surface\n    pygame.draw.rect(windowSurface, WHITE, player)\n\n    # check if the player has intersected with any food squares.\n    for food in foods[:]:\n        if player.colliderect(food):\n            foods.remove(food)\n\n    # draw the food\n    for i in range(len(foods)):\n        pygame.draw.rect(windowSurface, GREEN, foods[i])\n\n    # draw the window onto the screen\n    pygame.display.update()\n    mainClock.tick(40)\n",
    "reversi":"# Reversi\n\nimport random\nimport sys\n\ndef drawBoard(board):\n    # This function prints out the board that it was passed. Returns None.\n    HLINE = \'  +---+---+---+---+---+---+---+---+\'\n    VLINE = \'  |   |   |   |   |   |   |   |   |\'\n\n    print(\'    1   2   3   4   5   6   7   8\')\n    print(HLINE)\n    for y in range(8):\n        print(VLINE)\n        print(y+1, end=\' \')\n        for x in range(8):\n            print(\'| %s\' % (board[x][y]), end=\' \')\n        print(\'|\')\n        print(VLINE)\n        print(HLINE)\n\n\ndef resetBoard(board):\n    # Blanks out the board it is passed, except for the original starting position.\n    for x in range(8):\n        for y in range(8):\n            board[x][y] = \' \'\n\n    # Starting pieces:\n    board[3][3] = \'X\'\n    board[3][4] = \'O\'\n    board[4][3] = \'O\'\n    board[4][4] = \'X\'\n\n\ndef getNewBoard():\n    # Creates a brand new, blank board data structure.\n    board = []\n    for i in range(8):\n        board.append([\' \'] * 8)\n\n    return board\n\n\ndef isValidMove(board, tile, xstart, ystart):\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\n        return False\n\n    board[xstart][ystart] = tile # temporarily set the tile on the board.\n\n    if tile == \'X\':\n        otherTile = \'O\'\n    else:\n        otherTile = \'X\'\n\n    tilesToFlip = []\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\n        x, y = xstart, ystart\n        x += xdirection # first step in the direction\n        y += ydirection # first step in the direction\n        if isOnBoard(x, y) and board[x][y] == otherTile:\n            # There is a piece belonging to the other player next to our piece.\n            x += xdirection\n            y += ydirection\n            if not isOnBoard(x, y):\n                continue\n            while board[x][y] == otherTile:\n                x += xdirection\n                y += ydirection\n                if not isOnBoard(x, y): # break out of while loop, then continue in for loop\n                    break\n            if not isOnBoard(x, y):\n                continue\n            if board[x][y] == tile:\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\n                while True:\n                    x -= xdirection\n                    y -= ydirection\n                    if x == xstart and y == ystart:\n                        break\n                    tilesToFlip.append([x, y])\n\n    board[xstart][ystart] = \' \' # restore the empty space\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\n        return False\n    return tilesToFlip\n\n\ndef isOnBoard(x, y):\n    # Returns True if the coordinates are located on the board.\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\n\n\ndef getBoardWithValidMoves(board, tile):\n    # Returns a new board with . marking the valid moves the given player can make.\n    dupeBoard = getBoardCopy(board)\n\n    for x, y in getValidMoves(dupeBoard, tile):\n        dupeBoard[x][y] = \'.\'\n    return dupeBoard\n\n\ndef getValidMoves(board, tile):\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\n    validMoves = []\n\n    for x in range(8):\n        for y in range(8):\n            if isValidMove(board, tile, x, y) != False:\n                validMoves.append([x, y])\n    return validMoves\n\n\ndef getScoreOfBoard(board):\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\n    xscore = 0\n    oscore = 0\n    for x in range(8):\n        for y in range(8):\n            if board[x][y] == \'X\':\n                xscore += 1\n            if board[x][y] == \'O\':\n                oscore += 1\n    return {\'X\':xscore, \'O\':oscore}\n\n\ndef enterPlayerTile():\n    # Let\'s the player type which tile they want to be.\n    # Returns a list with the player\'s tile as the first item, and the computer\'s tile as the second.\n    tile = \'\'\n    while not (tile == \'X\' or tile == \'O\'):\n        print(\'Do you want to be X or O?\')\n        tile = input().upper()\n\n    # the first element in the tuple is the player\'s tile, the second is the computer\'s tile.\n    if tile == \'X\':\n        return [\'X\', \'O\']\n    else:\n        return [\'O\', \'X\']\n\n\ndef whoGoesFirst():\n    # Randomly choose the player who goes first.\n    if random.randint(0, 1) == 0:\n        return \'computer\'\n    else:\n        return \'player\'\n\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\n\ndef makeMove(board, tile, xstart, ystart):\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\n    # Returns False if this is an invalid move, True if it is valid.\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\n\n    if tilesToFlip == False:\n        return False\n\n    board[xstart][ystart] = tile\n    for x, y in tilesToFlip:\n        board[x][y] = tile\n    return True\n\n\ndef getBoardCopy(board):\n    # Make a duplicate of the board list and return the duplicate.\n    dupeBoard = getNewBoard()\n\n    for x in range(8):\n        for y in range(8):\n            dupeBoard[x][y] = board[x][y]\n\n    return dupeBoard\n\n\ndef isOnCorner(x, y):\n    # Returns True if the position is in one of the four corners.\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\n\n\ndef getPlayerMove(board, playerTile):\n    # Let the player type in their move.\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\')\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\n    while True:\n        print(\'Enter your move, or type quit to end the game, or hints to turn off/on hints.\')\n        move = input().lower()\n        if move == \'quit\':\n            return \'quit\'\n        if move == \'hints\':\n            return \'hints\'\n\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\n            x = int(move[0]) - 1\n            y = int(move[1]) - 1\n            if isValidMove(board, playerTile, x, y) == False:\n                continue\n            else:\n                break\n        else:\n            print(\'That is not a valid move. Type the x digit (1-8), then the y digit (1-8).\')\n            print(\'For example, 81 will be the top-right corner.\')\n\n    return [x, y]\n\n\ndef getComputerMove(board, computerTile):\n    # Given a board and the computer\'s tile, determine where to\n    # move and return that move as a [x, y] list.\n    possibleMoves = getValidMoves(board, computerTile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    # Go through all the possible moves and remember the best scoring move\n    bestScore = -1\n    for x, y in possibleMoves:\n        dupeBoard = getBoardCopy(board)\n        makeMove(dupeBoard, computerTile, x, y)\n        score = getScoreOfBoard(dupeBoard)[computerTile]\n        if score > bestScore:\n            bestMove = [x, y]\n            bestScore = score\n    return bestMove\n\n\ndef showPoints(playerTile, computerTile):\n    # Prints out the current score.\n    scores = getScoreOfBoard(mainBoard)\n    print(\'You have %s points. The computer has %s points.\' % (scores[playerTile], scores[computerTile]))\n\n\n\nprint(\'Welcome to Reversi!\')\n\nwhile True:\n    # Reset the board and game.\n    mainBoard = getNewBoard()\n    resetBoard(mainBoard)\n    playerTile, computerTile = enterPlayerTile()\n    showHints = False\n    turn = whoGoesFirst()\n    print(\'The \' + turn + \' will go first.\')\n\n    while True:\n        if turn == \'player\':\n            # Player\'s turn.\n            if showHints:\n                validMovesBoard = getBoardWithValidMoves(mainBoard, playerTile)\n                drawBoard(validMovesBoard)\n            else:\n                drawBoard(mainBoard)\n            showPoints(playerTile, computerTile)\n            move = getPlayerMove(mainBoard, playerTile)\n            if move == \'quit\':\n                print(\'Thanks for playing!\')\n                sys.exit() # terminate the program\n            elif move == \'hints\':\n                showHints = not showHints\n                continue\n            else:\n                makeMove(mainBoard, playerTile, move[0], move[1])\n\n            if getValidMoves(mainBoard, computerTile) == []:\n                break\n            else:\n                turn = \'computer\'\n\n        else:\n            # Computer\'s turn.\n            drawBoard(mainBoard)\n            showPoints(playerTile, computerTile)\n            input(\'Press Enter to see the computer\\\'s move.\')\n            x, y = getComputerMove(mainBoard, computerTile)\n            makeMove(mainBoard, computerTile, x, y)\n\n            if getValidMoves(mainBoard, playerTile) == []:\n                break\n            else:\n                turn = \'player\'\n\n    # Display the final score.\n    drawBoard(mainBoard)\n    scores = getScoreOfBoard(mainBoard)\n    print(\'X scored %s points. O scored %s points.\' % (scores[\'X\'], scores[\'O\']))\n    if scores[playerTile] > scores[computerTile]:\n        print(\'You beat the computer by %s points! Congratulations!\' % (scores[playerTile] - scores[computerTile]))\n    elif scores[playerTile] < scores[computerTile]:\n        print(\'You lost. The computer beat you by %s points.\' % (scores[computerTile] - scores[playerTile]))\n    else:\n        print(\'The game was a tie!\')\n\n    if not playAgain():\n        break\n",
    "sonar":"# Sonar\n\nimport random\nimport sys\n\ndef drawBoard(board):\n    # Draw the board data structure.\n\n    hline = \'    \' # initial space for the numbers down the left side of the board\n    for i in range(1, 6):\n        hline += (\' \' * 9) + str(i)\n\n    # print the numbers across the top\n    print(hline)\n    print(\'   \' + (\'0123456789\' * 6))\n    print()\n\n    # print each of the 15 rows\n    for i in range(15):\n        # single-digit numbers need to be padded with an extra space\n        if i < 10:\n            extraSpace = \' \'\n        else:\n            extraSpace = \'\'\n        print(\'%s%s %s %s\' % (extraSpace, i, getRow(board, i), i))\n\n    # print the numbers across the bottom\n    print()\n    print(\'   \' + (\'0123456789\' * 6))\n    print(hline)\n\n\ndef getRow(board, row):\n    # Return a string from the board data structure at a certain row.\n    boardRow = \'\'\n    for i in range(60):\n        boardRow += board[i][row]\n    return boardRow\n\ndef getNewBoard():\n    # Create a new 60x15 board data structure.\n    board = []\n    for x in range(60): # the main list is a list of 60 lists\n        board.append([])\n        for y in range(15): # each list in the main list has 15 single-character strings\n            # use different characters for the ocean to make it more readable.\n            if random.randint(0, 1) == 0:\n                board[x].append(\'~\')\n            else:\n                board[x].append(\'`\')\n    return board\n\ndef getRandomChests(numChests):\n    # Create a list of chest data structures (two-item lists of x, y int coordinates)\n    chests = []\n    for i in range(numChests):\n        chests.append([random.randint(0, 59), random.randint(0, 14)])\n    return chests\n\ndef isValidMove(x, y):\n    # Return True if the coordinates are on the board, otherwise False.\n    return x >= 0 and x <= 59 and y >= 0 and y <= 14\n\ndef makeMove(board, chests, x, y):\n    # Change the board data structure with a sonar device character. Remove treasure chests\n    # from the chests list as they are found. Return False if this is an invalid move.\n    # Otherwise, return the string of the result of this move.\n    if not isValidMove(x, y):\n        return False\n\n    smallestDistance = 100 # any chest will be closer than 100.\n    for cx, cy in chests:\n        if abs(cx - x) > abs(cy - y):\n            distance = abs(cx - x)\n        else:\n            distance = abs(cy - y)\n\n        if distance < smallestDistance: # we want the closest treasure chest.\n            smallestDistance = distance\n\n    if smallestDistance == 0:\n        # xy is directly on a treasure chest!\n        chests.remove([x, y])\n        return \'You have found a sunken treasure chest!\'\n    else:\n        if smallestDistance < 10:\n            board[x][y] = str(smallestDistance)\n            return \'Treasure detected at a distance of %s from the sonar device.\' % (smallestDistance)\n        else:\n            board[x][y] = \'O\'\n            return \'Sonar did not detect anything. All treasure chests out of range.\'\n\n\ndef enterPlayerMove():\n    # Let the player type in their move. Return a two-item list of int xy coordinates.\n    print(\'Where do you want to drop the next sonar device? (0-59 0-14) (or type quit)\')\n    while True:\n        move = input()\n        if move.lower() == \'quit\':\n            print(\'Thanks for playing!\')\n            sys.exit()\n\n        move = move.split()\n        if len(move) == 2 and move[0].isdigit() and move[1].isdigit() and isValidMove(int(move[0]), int(move[1])):\n            return [int(move[0]), int(move[1])]\n        print(\'Enter a number from 0 to 59, a space, then a number from 0 to 14.\')\n\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\n\ndef showInstructions():\n    print(\'\'\'Instructions:\nYou are the captain of the Simon, a treasure-hunting ship. Your current mission\nis to find the three sunken treasure chests that are lurking in the part of the\nocean you are in and collect them.\n\nTo play, enter the coordinates of the point in the ocean you wish to drop a\nsonar device. The sonar can find out how far away the closest chest is to it.\nFor example, the d below marks where the device was dropped, and the 2\'s\nrepresent distances of 2 away from the device. The 4\'s represent\ndistances of 4 away from the device.\n\n    444444444\n    4       4\n    4 22222 4\n    4 2   2 4\n    4 2 d 2 4\n    4 2   2 4\n    4 22222 4\n    4       4\n    444444444\nPress enter to continue...\'\'\')\n    input()\n\n    print(\'\'\'For example, here is a treasure chest (the c) located a distance of 2 away\nfrom the sonar device (the d):\n\n    22222\n    c   2\n    2 d 2\n    2   2\n    22222\n\nThe point where the device was dropped will be marked with a d.\n\nThe treasure chests don\'t move around. Sonar devices can detect treasure\nchests up to a distance of 9. If all chests are out of range, the point\nwill be marked with O\n\nIf a device is directly dropped on a treasure chest, you have discovered\nthe location of the chest, and it will be collected. The sonar device will\nremain there.\n\nWhen you collect a chest, all sonar devices will update to locate the next\nclosest sunken treasure chest.\nPress enter to continue...\'\'\')\n    input()\n    print()\n\n\nprint(\'S O N A R !\')\nprint()\nprint(\'Would you like to view the instructions? (yes/no)\')\nif input().lower().startswith(\'y\'):\n    showInstructions()\n\nwhile True:\n    # game setup\n    sonarDevices = 16\n    theBoard = getNewBoard()\n    theChests = getRandomChests(3)\n    drawBoard(theBoard)\n    previousMoves = []\n\n    while sonarDevices > 0:\n        # Start of a turn:\n\n        # show sonar device/chest status\n        if sonarDevices > 1: extraSsonar = \'s\'\n        else: extraSsonar = \'\'\n        if len(theChests) > 1: extraSchest = \'s\'\n        else: extraSchest = \'\'\n        print(\'You have %s sonar device%s left. %s treasure chest%s remaining.\' % (sonarDevices, extraSsonar, len(theChests), extraSchest))\n\n        x, y = enterPlayerMove()\n        previousMoves.append([x, y]) # we must track all moves so that sonar devices can be updated.\n\n        moveResult = makeMove(theBoard, theChests, x, y)\n        if moveResult == False:\n            continue\n        else:\n            if moveResult == \'You have found a sunken treasure chest!\':\n                # update all the sonar devices currently on the map.\n                for x, y in previousMoves:\n                    makeMove(theBoard, theChests, x, y)\n            drawBoard(theBoard)\n            print(moveResult)\n\n        if len(theChests) == 0:\n            print(\'You have found all the sunken treasure chests! Congratulations and good game!\')\n            break\n\n        sonarDevices -= 1\n\n    if sonarDevices == 0:\n        print(\'We\\\'ve run out of sonar devices! Now we have to turn the ship around and head\')\n        print(\'for home with treasure chests still out there! Game over.\')\n        print(\'    The remaining chests were here:\')\n        for x, y in theChests:\n            print(\'    %s, %s\' % (x, y))\n\n    if not playAgain():\n        sys.exit()\n",
    "spritesAndSounds":"import pygame, sys, time, random\nfrom pygame.locals import *\n\n# set up pygame\npygame.init()\nmainClock = pygame.time.Clock()\n\n# set up the window\nWINDOWWIDTH = 400\nWINDOWHEIGHT = 400\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\npygame.display.set_caption(\'Sprites and Sound\')\n\n# set up the colors\nBLACK = (0, 0, 0)\n\n# set up the block data structure\nplayer = pygame.Rect(300, 100, 40, 40)\nplayerImage = pygame.image.load(\'player.png\')\nplayerStretchedImage = pygame.transform.scale(playerImage, (40, 40))\nfoodImage = pygame.image.load(\'cherry.png\')\nfoods = []\nfor i in range(20):\n    foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - 20), random.randint(0, WINDOWHEIGHT - 20), 20, 20))\n\nfoodCounter = 0\nNEWFOOD = 40\n\n# set up keyboard variables\nmoveLeft = False\nmoveRight = False\nmoveUp = False\nmoveDown = False\n\nMOVESPEED = 6\n\n# set up music\npickUpSound = pygame.mixer.Sound(\'pickup.wav\')\npygame.mixer.music.load(\'background.mid\')\npygame.mixer.music.play(-1, 0.0)\nmusicPlaying = True\n\n# run the game loop\nwhile True:\n    # check for the QUIT event\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == KEYDOWN:\n            # change the keyboard variables\n            if event.key == K_LEFT or event.key == ord(\'a\'):\n                moveRight = False\n                moveLeft = True\n            if event.key == K_RIGHT or event.key == ord(\'d\'):\n                moveLeft = False\n                moveRight = True\n            if event.key == K_UP or event.key == ord(\'w\'):\n                moveDown = False\n                moveUp = True\n            if event.key == K_DOWN or event.key == ord(\'s\'):\n                moveUp = False\n                moveDown = True\n        if event.type == KEYUP:\n            if event.key == K_ESCAPE:\n                pygame.quit()\n                sys.exit()\n            if event.key == K_LEFT or event.key == ord(\'a\'):\n                moveLeft = False\n            if event.key == K_RIGHT or event.key == ord(\'d\'):\n                moveRight = False\n            if event.key == K_UP or event.key == ord(\'w\'):\n                moveUp = False\n            if event.key == K_DOWN or event.key == ord(\'s\'):\n                moveDown = False\n            if event.key == ord(\'x\'):\n                player.top = random.randint(0, WINDOWHEIGHT - player.height)\n                player.left = random.randint(0, WINDOWWIDTH - player.width)\n            if event.key == ord(\'m\'):\n                if musicPlaying:\n                    pygame.mixer.music.stop()\n                else:\n                    pygame.mixer.music.play(-1, 0.0)\n                musicPlaying = not musicPlaying\n\n        if event.type == MOUSEBUTTONUP:\n            foods.append(pygame.Rect(event.pos[0] - 10, event.pos[1] - 10, 20, 20))\n\n    foodCounter += 1\n    if foodCounter >= NEWFOOD:\n        # add new food\n        foodCounter = 0\n        foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - 20), random.randint(0, WINDOWHEIGHT - 20), 20, 20))\n\n    # draw the black background onto the surface\n    windowSurface.fill(BLACK)\n\n    # move the player\n    if moveDown and player.bottom < WINDOWHEIGHT:\n        player.top += MOVESPEED\n    if moveUp and player.top > 0:\n        player.top -= MOVESPEED\n    if moveLeft and player.left > 0:\n        player.left -= MOVESPEED\n    if moveRight and player.right < WINDOWWIDTH:\n        player.right += MOVESPEED\n\n\n    # draw the block onto the surface\n    windowSurface.blit(playerStretchedImage, player)\n\n    # check if the block has intersected with any food squares.\n    for food in foods[:]:\n        if player.colliderect(food):\n            foods.remove(food)\n            player = pygame.Rect(player.left, player.top, player.width + 2, player.height + 2)\n            playerStretchedImage = pygame.transform.scale(playerImage, (player.width, player.height))\n            if musicPlaying:\n                pickUpSound.play()\n\n    # draw the food\n    for food in foods:\n        windowSurface.blit(foodImage, food)\n\n    # draw the window onto the screen\n    pygame.display.update()\n    mainClock.tick(40)\n",
    "tictactoe":"# Tic Tac Toe\n\nimport random\n\ndef drawBoard(board):\n    # This function prints out the board that it was passed.\n\n    # \"board\" is a list of 10 strings representing the board (ignore index 0)\n    print(\'   |   |\')\n    print(\' \' + board[7] + \' | \' + board[8] + \' | \' + board[9])\n    print(\'   |   |\')\n    print(\'-----------\')\n    print(\'   |   |\')\n    print(\' \' + board[4] + \' | \' + board[5] + \' | \' + board[6])\n    print(\'   |   |\')\n    print(\'-----------\')\n    print(\'   |   |\')\n    print(\' \' + board[1] + \' | \' + board[2] + \' | \' + board[3])\n    print(\'   |   |\')\n\ndef inputPlayerLetter():\n    # Let\'s the player type which letter they want to be.\n    # Returns a list with the player\'s letter as the first item, and the computer\'s letter as the second.\n    letter = \'\'\n    while not (letter == \'X\' or letter == \'O\'):\n        print(\'Do you want to be X or O?\')\n        letter = input().upper()\n\n    # the first element in the tuple is the player\'s letter, the second is the computer\'s letter.\n    if letter == \'X\':\n        return [\'X\', \'O\']\n    else:\n        return [\'O\', \'X\']\n\ndef whoGoesFirst():\n    # Randomly choose the player who goes first.\n    if random.randint(0, 1) == 0:\n        return \'computer\'\n    else:\n        return \'player\'\n\ndef playAgain():\n    # This function returns True if the player wants to play again, otherwise it returns False.\n    print(\'Do you want to play again? (yes or no)\')\n    return input().lower().startswith(\'y\')\n\ndef makeMove(board, letter, move):\n    board[move] = letter\n\ndef isWinner(bo, le):\n    # Given a board and a player\'s letter, this function returns True if that player has won.\n    # We use bo instead of board and le instead of letter so we don\'t have to type as much.\n    return ((bo[7] == le and bo[8] == le and bo[9] == le) or # across the top\n    (bo[4] == le and bo[5] == le and bo[6] == le) or # across the middle\n    (bo[1] == le and bo[2] == le and bo[3] == le) or # across the bottom\n    (bo[7] == le and bo[4] == le and bo[1] == le) or # down the left side\n    (bo[8] == le and bo[5] == le and bo[2] == le) or # down the middle\n    (bo[9] == le and bo[6] == le and bo[3] == le) or # down the right side\n    (bo[7] == le and bo[5] == le and bo[3] == le) or # diagonal\n    (bo[9] == le and bo[5] == le and bo[1] == le)) # diagonal\n\ndef getBoardCopy(board):\n    # Make a duplicate of the board list and return it the duplicate.\n    dupeBoard = []\n\n    for i in board:\n        dupeBoard.append(i)\n\n    return dupeBoard\n\ndef isSpaceFree(board, move):\n    # Return true if the passed move is free on the passed board.\n    return board[move] == \' \'\n\ndef getPlayerMove(board):\n    # Let the player type in their move.\n    move = \' \'\n    while move not in \'1 2 3 4 5 6 7 8 9\'.split() or not isSpaceFree(board, int(move)):\n        print(\'What is your next move? (1-9)\')\n        move = input()\n    return int(move)\n\ndef chooseRandomMoveFromList(board, movesList):\n    # Returns a valid move from the passed list on the passed board.\n    # Returns None if there is no valid move.\n    possibleMoves = []\n    for i in movesList:\n        if isSpaceFree(board, i):\n            possibleMoves.append(i)\n\n    if len(possibleMoves) != 0:\n        return random.choice(possibleMoves)\n    else:\n        return None\n\ndef getComputerMove(board, computerLetter):\n    # Given a board and the computer\'s letter, determine where to move and return that move.\n    if computerLetter == \'X\':\n        playerLetter = \'O\'\n    else:\n        playerLetter = \'X\'\n\n    # Here is our algorithm for our Tic Tac Toe AI:\n    # First, check if we can win in the next move\n    for i in range(1, 10):\n        copy = getBoardCopy(board)\n        if isSpaceFree(copy, i):\n            makeMove(copy, computerLetter, i)\n            if isWinner(copy, computerLetter):\n                return i\n\n    # Check if the player could win on their next move, and block them.\n    for i in range(1, 10):\n        copy = getBoardCopy(board)\n        if isSpaceFree(copy, i):\n            makeMove(copy, playerLetter, i)\n            if isWinner(copy, playerLetter):\n                return i\n\n    # Try to take one of the corners, if they are free.\n    move = chooseRandomMoveFromList(board, [1, 3, 7, 9])\n    if move != None:\n        return move\n\n    # Try to take the center, if it is free.\n    if isSpaceFree(board, 5):\n        return 5\n\n    # Move on one of the sides.\n    return chooseRandomMoveFromList(board, [2, 4, 6, 8])\n\ndef isBoardFull(board):\n    # Return True if every space on the board has been taken. Otherwise return False.\n    for i in range(1, 10):\n        if isSpaceFree(board, i):\n            return False\n    return True\n\n\nprint(\'Welcome to Tic Tac Toe!\')\n\nwhile True:\n    # Reset the board\n    theBoard = [\' \'] * 10\n    playerLetter, computerLetter = inputPlayerLetter()\n    turn = whoGoesFirst()\n    print(\'The \' + turn + \' will go first.\')\n    gameIsPlaying = True\n\n    while gameIsPlaying:\n        if turn == \'player\':\n            # Player\'s turn.\n            drawBoard(theBoard)\n            move = getPlayerMove(theBoard)\n            makeMove(theBoard, playerLetter, move)\n\n            if isWinner(theBoard, playerLetter):\n                drawBoard(theBoard)\n                print(\'Hooray! You have won the game!\')\n                gameIsPlaying = False\n            else:\n                if isBoardFull(theBoard):\n                    drawBoard(theBoard)\n                    print(\'The game is a tie!\')\n                    break\n                else:\n                    turn = \'computer\'\n\n        else:\n            # Computer\'s turn.\n            move = getComputerMove(theBoard, computerLetter)\n            makeMove(theBoard, computerLetter, move)\n\n            if isWinner(theBoard, computerLetter):\n                drawBoard(theBoard)\n                print(\'The computer has beaten you! You lose.\')\n                gameIsPlaying = False\n            else:\n                if isBoardFull(theBoard):\n                    drawBoard(theBoard)\n                    print(\'The game is a tie!\')\n                    break\n                else:\n                    turn = \'player\'\n\n    if not playAgain():\n        break\n"
};
